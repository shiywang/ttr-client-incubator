// This file is generated by rust-protobuf 2.7.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `IM.BaseDefine.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_7_0;

#[derive(PartialEq,Clone,Default,Debug)]
pub struct IpAddr {
    // message fields
    ip: ::protobuf::SingularField<::std::string::String>,
    port: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IpAddr {
    fn default() -> &'a IpAddr {
        <IpAddr as ::protobuf::Message>::default_instance()
    }
}

impl IpAddr {
    pub fn new() -> IpAddr {
        ::std::default::Default::default()
    }

    // required string ip = 1;


    pub fn get_ip(&self) -> &str {
        match self.ip.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_ip(&mut self) {
        self.ip.clear();
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: ::std::string::String) {
        self.ip = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip(&mut self) -> &mut ::std::string::String {
        if self.ip.is_none() {
            self.ip.set_default();
        }
        self.ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip(&mut self) -> ::std::string::String {
        self.ip.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint32 port = 2;


    pub fn get_port(&self) -> u32 {
        self.port.unwrap_or(0)
    }
    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for IpAddr {
    fn is_initialized(&self) -> bool {
        if self.ip.is_none() {
            return false;
        }
        if self.port.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ip)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ip.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.port {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ip.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.port {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IpAddr {
        IpAddr::new()
    }

    fn default_instance() -> &'static IpAddr {
        static mut instance: ::protobuf::lazy::Lazy<IpAddr> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IpAddr,
        };
        unsafe {
            instance.get(IpAddr::new)
        }
    }
}

impl ::protobuf::Clear for IpAddr {
    fn clear(&mut self) {
        self.ip.clear();
        self.port = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for IpAddr {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct UserInfo {
    // message fields
    user_id: ::std::option::Option<u32>,
    user_gender: ::std::option::Option<u32>,
    user_nick_name: ::protobuf::SingularField<::std::string::String>,
    avatar_url: ::protobuf::SingularField<::std::string::String>,
    department_id: ::std::option::Option<u32>,
    email: ::protobuf::SingularField<::std::string::String>,
    user_real_name: ::protobuf::SingularField<::std::string::String>,
    user_tel: ::protobuf::SingularField<::std::string::String>,
    user_domain: ::protobuf::SingularField<::std::string::String>,
    status: ::std::option::Option<u32>,
    sign_info: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserInfo {
    fn default() -> &'a UserInfo {
        <UserInfo as ::protobuf::Message>::default_instance()
    }
}

impl UserInfo {
    pub fn new() -> UserInfo {
        ::std::default::Default::default()
    }

    // required uint32 user_id = 1;


    pub fn get_user_id(&self) -> u32 {
        self.user_id.unwrap_or(0)
    }
    pub fn clear_user_id(&mut self) {
        self.user_id = ::std::option::Option::None;
    }

    pub fn has_user_id(&self) -> bool {
        self.user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: u32) {
        self.user_id = ::std::option::Option::Some(v);
    }

    // required uint32 user_gender = 2;


    pub fn get_user_gender(&self) -> u32 {
        self.user_gender.unwrap_or(0)
    }
    pub fn clear_user_gender(&mut self) {
        self.user_gender = ::std::option::Option::None;
    }

    pub fn has_user_gender(&self) -> bool {
        self.user_gender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_gender(&mut self, v: u32) {
        self.user_gender = ::std::option::Option::Some(v);
    }

    // required string user_nick_name = 3;


    pub fn get_user_nick_name(&self) -> &str {
        match self.user_nick_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_user_nick_name(&mut self) {
        self.user_nick_name.clear();
    }

    pub fn has_user_nick_name(&self) -> bool {
        self.user_nick_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_nick_name(&mut self, v: ::std::string::String) {
        self.user_nick_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_nick_name(&mut self) -> &mut ::std::string::String {
        if self.user_nick_name.is_none() {
            self.user_nick_name.set_default();
        }
        self.user_nick_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_nick_name(&mut self) -> ::std::string::String {
        self.user_nick_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string avatar_url = 4;


    pub fn get_avatar_url(&self) -> &str {
        match self.avatar_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_avatar_url(&mut self) {
        self.avatar_url.clear();
    }

    pub fn has_avatar_url(&self) -> bool {
        self.avatar_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avatar_url(&mut self, v: ::std::string::String) {
        self.avatar_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar_url(&mut self) -> &mut ::std::string::String {
        if self.avatar_url.is_none() {
            self.avatar_url.set_default();
        }
        self.avatar_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_avatar_url(&mut self) -> ::std::string::String {
        self.avatar_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint32 department_id = 5;


    pub fn get_department_id(&self) -> u32 {
        self.department_id.unwrap_or(0)
    }
    pub fn clear_department_id(&mut self) {
        self.department_id = ::std::option::Option::None;
    }

    pub fn has_department_id(&self) -> bool {
        self.department_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_department_id(&mut self, v: u32) {
        self.department_id = ::std::option::Option::Some(v);
    }

    // required string email = 6;


    pub fn get_email(&self) -> &str {
        match self.email.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_email(&mut self) {
        self.email.clear();
    }

    pub fn has_email(&self) -> bool {
        self.email.is_some()
    }

    // Param is passed by value, moved
    pub fn set_email(&mut self, v: ::std::string::String) {
        self.email = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_email(&mut self) -> &mut ::std::string::String {
        if self.email.is_none() {
            self.email.set_default();
        }
        self.email.as_mut().unwrap()
    }

    // Take field
    pub fn take_email(&mut self) -> ::std::string::String {
        self.email.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string user_real_name = 7;


    pub fn get_user_real_name(&self) -> &str {
        match self.user_real_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_user_real_name(&mut self) {
        self.user_real_name.clear();
    }

    pub fn has_user_real_name(&self) -> bool {
        self.user_real_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_real_name(&mut self, v: ::std::string::String) {
        self.user_real_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_real_name(&mut self) -> &mut ::std::string::String {
        if self.user_real_name.is_none() {
            self.user_real_name.set_default();
        }
        self.user_real_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_real_name(&mut self) -> ::std::string::String {
        self.user_real_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string user_tel = 8;


    pub fn get_user_tel(&self) -> &str {
        match self.user_tel.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_user_tel(&mut self) {
        self.user_tel.clear();
    }

    pub fn has_user_tel(&self) -> bool {
        self.user_tel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_tel(&mut self, v: ::std::string::String) {
        self.user_tel = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_tel(&mut self) -> &mut ::std::string::String {
        if self.user_tel.is_none() {
            self.user_tel.set_default();
        }
        self.user_tel.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_tel(&mut self) -> ::std::string::String {
        self.user_tel.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string user_domain = 9;


    pub fn get_user_domain(&self) -> &str {
        match self.user_domain.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_user_domain(&mut self) {
        self.user_domain.clear();
    }

    pub fn has_user_domain(&self) -> bool {
        self.user_domain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_domain(&mut self, v: ::std::string::String) {
        self.user_domain = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_domain(&mut self) -> &mut ::std::string::String {
        if self.user_domain.is_none() {
            self.user_domain.set_default();
        }
        self.user_domain.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_domain(&mut self) -> ::std::string::String {
        self.user_domain.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint32 status = 10;


    pub fn get_status(&self) -> u32 {
        self.status.unwrap_or(0)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: u32) {
        self.status = ::std::option::Option::Some(v);
    }

    // optional string sign_info = 11;


    pub fn get_sign_info(&self) -> &str {
        match self.sign_info.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_sign_info(&mut self) {
        self.sign_info.clear();
    }

    pub fn has_sign_info(&self) -> bool {
        self.sign_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sign_info(&mut self, v: ::std::string::String) {
        self.sign_info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sign_info(&mut self) -> &mut ::std::string::String {
        if self.sign_info.is_none() {
            self.sign_info.set_default();
        }
        self.sign_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_sign_info(&mut self) -> ::std::string::String {
        self.sign_info.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for UserInfo {
    fn is_initialized(&self) -> bool {
        if self.user_id.is_none() {
            return false;
        }
        if self.user_gender.is_none() {
            return false;
        }
        if self.user_nick_name.is_none() {
            return false;
        }
        if self.avatar_url.is_none() {
            return false;
        }
        if self.department_id.is_none() {
            return false;
        }
        if self.email.is_none() {
            return false;
        }
        if self.user_real_name.is_none() {
            return false;
        }
        if self.user_tel.is_none() {
            return false;
        }
        if self.user_domain.is_none() {
            return false;
        }
        if self.status.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.user_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.user_gender = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.user_nick_name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.avatar_url)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.department_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.email)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.user_real_name)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.user_tel)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.user_domain)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.status = ::std::option::Option::Some(tmp);
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sign_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.user_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.user_gender {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.user_nick_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.avatar_url.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.department_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.email.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.user_real_name.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.user_tel.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.user_domain.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.sign_info.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.user_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.user_gender {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.user_nick_name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.avatar_url.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.department_id {
            os.write_uint32(5, v)?;
        }
        if let Some(ref v) = self.email.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.user_real_name.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.user_tel.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.user_domain.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(v) = self.status {
            os.write_uint32(10, v)?;
        }
        if let Some(ref v) = self.sign_info.as_ref() {
            os.write_string(11, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserInfo {
        UserInfo::new()
    }

    fn default_instance() -> &'static UserInfo {
        static mut instance: ::protobuf::lazy::Lazy<UserInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UserInfo,
        };
        unsafe {
            instance.get(UserInfo::new)
        }
    }
}

impl ::protobuf::Clear for UserInfo {
    fn clear(&mut self) {
        self.user_id = ::std::option::Option::None;
        self.user_gender = ::std::option::Option::None;
        self.user_nick_name.clear();
        self.avatar_url.clear();
        self.department_id = ::std::option::Option::None;
        self.email.clear();
        self.user_real_name.clear();
        self.user_tel.clear();
        self.user_domain.clear();
        self.status = ::std::option::Option::None;
        self.sign_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for UserInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct ContactSessionInfo {
    // message fields
    session_id: ::std::option::Option<u32>,
    session_type: ::std::option::Option<SessionType>,
    session_status: ::std::option::Option<SessionStatusType>,
    updated_time: ::std::option::Option<u32>,
    latest_msg_id: ::std::option::Option<u32>,
    latest_msg_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    latest_msg_type: ::std::option::Option<MsgType>,
    latest_msg_from_user_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContactSessionInfo {
    fn default() -> &'a ContactSessionInfo {
        <ContactSessionInfo as ::protobuf::Message>::default_instance()
    }
}

impl ContactSessionInfo {
    pub fn new() -> ContactSessionInfo {
        ::std::default::Default::default()
    }

    // required uint32 session_id = 1;


    pub fn get_session_id(&self) -> u32 {
        self.session_id.unwrap_or(0)
    }
    pub fn clear_session_id(&mut self) {
        self.session_id = ::std::option::Option::None;
    }

    pub fn has_session_id(&self) -> bool {
        self.session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_id(&mut self, v: u32) {
        self.session_id = ::std::option::Option::Some(v);
    }

    // required .IM.BaseDefine.SessionType session_type = 2;


    pub fn get_session_type(&self) -> SessionType {
        self.session_type.unwrap_or(SessionType::SESSION_TYPE_SINGLE)
    }
    pub fn clear_session_type(&mut self) {
        self.session_type = ::std::option::Option::None;
    }

    pub fn has_session_type(&self) -> bool {
        self.session_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_type(&mut self, v: SessionType) {
        self.session_type = ::std::option::Option::Some(v);
    }

    // required .IM.BaseDefine.SessionStatusType session_status = 3;


    pub fn get_session_status(&self) -> SessionStatusType {
        self.session_status.unwrap_or(SessionStatusType::SESSION_STATUS_OK)
    }
    pub fn clear_session_status(&mut self) {
        self.session_status = ::std::option::Option::None;
    }

    pub fn has_session_status(&self) -> bool {
        self.session_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_status(&mut self, v: SessionStatusType) {
        self.session_status = ::std::option::Option::Some(v);
    }

    // required uint32 updated_time = 4;


    pub fn get_updated_time(&self) -> u32 {
        self.updated_time.unwrap_or(0)
    }
    pub fn clear_updated_time(&mut self) {
        self.updated_time = ::std::option::Option::None;
    }

    pub fn has_updated_time(&self) -> bool {
        self.updated_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updated_time(&mut self, v: u32) {
        self.updated_time = ::std::option::Option::Some(v);
    }

    // required uint32 latest_msg_id = 5;


    pub fn get_latest_msg_id(&self) -> u32 {
        self.latest_msg_id.unwrap_or(0)
    }
    pub fn clear_latest_msg_id(&mut self) {
        self.latest_msg_id = ::std::option::Option::None;
    }

    pub fn has_latest_msg_id(&self) -> bool {
        self.latest_msg_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_latest_msg_id(&mut self, v: u32) {
        self.latest_msg_id = ::std::option::Option::Some(v);
    }

    // required bytes latest_msg_data = 6;


    pub fn get_latest_msg_data(&self) -> &[u8] {
        match self.latest_msg_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_latest_msg_data(&mut self) {
        self.latest_msg_data.clear();
    }

    pub fn has_latest_msg_data(&self) -> bool {
        self.latest_msg_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_latest_msg_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.latest_msg_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_latest_msg_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.latest_msg_data.is_none() {
            self.latest_msg_data.set_default();
        }
        self.latest_msg_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_latest_msg_data(&mut self) -> ::std::vec::Vec<u8> {
        self.latest_msg_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required .IM.BaseDefine.MsgType latest_msg_type = 7;


    pub fn get_latest_msg_type(&self) -> MsgType {
        self.latest_msg_type.unwrap_or(MsgType::MSG_TYPE_SINGLE_TEXT)
    }
    pub fn clear_latest_msg_type(&mut self) {
        self.latest_msg_type = ::std::option::Option::None;
    }

    pub fn has_latest_msg_type(&self) -> bool {
        self.latest_msg_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_latest_msg_type(&mut self, v: MsgType) {
        self.latest_msg_type = ::std::option::Option::Some(v);
    }

    // required uint32 latest_msg_from_user_id = 8;


    pub fn get_latest_msg_from_user_id(&self) -> u32 {
        self.latest_msg_from_user_id.unwrap_or(0)
    }
    pub fn clear_latest_msg_from_user_id(&mut self) {
        self.latest_msg_from_user_id = ::std::option::Option::None;
    }

    pub fn has_latest_msg_from_user_id(&self) -> bool {
        self.latest_msg_from_user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_latest_msg_from_user_id(&mut self, v: u32) {
        self.latest_msg_from_user_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ContactSessionInfo {
    fn is_initialized(&self) -> bool {
        if self.session_id.is_none() {
            return false;
        }
        if self.session_type.is_none() {
            return false;
        }
        if self.session_status.is_none() {
            return false;
        }
        if self.updated_time.is_none() {
            return false;
        }
        if self.latest_msg_id.is_none() {
            return false;
        }
        if self.latest_msg_data.is_none() {
            return false;
        }
        if self.latest_msg_type.is_none() {
            return false;
        }
        if self.latest_msg_from_user_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.session_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.session_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.session_status, 3, &mut self.unknown_fields)?
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.updated_time = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.latest_msg_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.latest_msg_data)?;
                },
                7 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.latest_msg_type, 7, &mut self.unknown_fields)?
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.latest_msg_from_user_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.session_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.session_type {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.session_status {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(v) = self.updated_time {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.latest_msg_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.latest_msg_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.latest_msg_type {
            my_size += ::protobuf::rt::enum_size(7, v);
        }
        if let Some(v) = self.latest_msg_from_user_id {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.session_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.session_type {
            os.write_enum(2, v.value())?;
        }
        if let Some(v) = self.session_status {
            os.write_enum(3, v.value())?;
        }
        if let Some(v) = self.updated_time {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.latest_msg_id {
            os.write_uint32(5, v)?;
        }
        if let Some(ref v) = self.latest_msg_data.as_ref() {
            os.write_bytes(6, &v)?;
        }
        if let Some(v) = self.latest_msg_type {
            os.write_enum(7, v.value())?;
        }
        if let Some(v) = self.latest_msg_from_user_id {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContactSessionInfo {
        ContactSessionInfo::new()
    }

    fn default_instance() -> &'static ContactSessionInfo {
        static mut instance: ::protobuf::lazy::Lazy<ContactSessionInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ContactSessionInfo,
        };
        unsafe {
            instance.get(ContactSessionInfo::new)
        }
    }
}

impl ::protobuf::Clear for ContactSessionInfo {
    fn clear(&mut self) {
        self.session_id = ::std::option::Option::None;
        self.session_type = ::std::option::Option::None;
        self.session_status = ::std::option::Option::None;
        self.updated_time = ::std::option::Option::None;
        self.latest_msg_id = ::std::option::Option::None;
        self.latest_msg_data.clear();
        self.latest_msg_type = ::std::option::Option::None;
        self.latest_msg_from_user_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for ContactSessionInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct UserStat {
    // message fields
    user_id: ::std::option::Option<u32>,
    status: ::std::option::Option<UserStatType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserStat {
    fn default() -> &'a UserStat {
        <UserStat as ::protobuf::Message>::default_instance()
    }
}

impl UserStat {
    pub fn new() -> UserStat {
        ::std::default::Default::default()
    }

    // required uint32 user_id = 1;


    pub fn get_user_id(&self) -> u32 {
        self.user_id.unwrap_or(0)
    }
    pub fn clear_user_id(&mut self) {
        self.user_id = ::std::option::Option::None;
    }

    pub fn has_user_id(&self) -> bool {
        self.user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: u32) {
        self.user_id = ::std::option::Option::Some(v);
    }

    // required .IM.BaseDefine.UserStatType status = 2;


    pub fn get_status(&self) -> UserStatType {
        self.status.unwrap_or(UserStatType::USER_STATUS_ONLINE)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: UserStatType) {
        self.status = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for UserStat {
    fn is_initialized(&self) -> bool {
        if self.user_id.is_none() {
            return false;
        }
        if self.status.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.user_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.user_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.user_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.status {
            os.write_enum(2, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserStat {
        UserStat::new()
    }

    fn default_instance() -> &'static UserStat {
        static mut instance: ::protobuf::lazy::Lazy<UserStat> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UserStat,
        };
        unsafe {
            instance.get(UserStat::new)
        }
    }
}

impl ::protobuf::Clear for UserStat {
    fn clear(&mut self) {
        self.user_id = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for UserStat {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct ServerUserStat {
    // message fields
    user_id: ::std::option::Option<u32>,
    status: ::std::option::Option<UserStatType>,
    client_type: ::std::option::Option<ClientType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServerUserStat {
    fn default() -> &'a ServerUserStat {
        <ServerUserStat as ::protobuf::Message>::default_instance()
    }
}

impl ServerUserStat {
    pub fn new() -> ServerUserStat {
        ::std::default::Default::default()
    }

    // required uint32 user_id = 1;


    pub fn get_user_id(&self) -> u32 {
        self.user_id.unwrap_or(0)
    }
    pub fn clear_user_id(&mut self) {
        self.user_id = ::std::option::Option::None;
    }

    pub fn has_user_id(&self) -> bool {
        self.user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: u32) {
        self.user_id = ::std::option::Option::Some(v);
    }

    // required .IM.BaseDefine.UserStatType status = 2;


    pub fn get_status(&self) -> UserStatType {
        self.status.unwrap_or(UserStatType::USER_STATUS_ONLINE)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: UserStatType) {
        self.status = ::std::option::Option::Some(v);
    }

    // required .IM.BaseDefine.ClientType client_type = 3;


    pub fn get_client_type(&self) -> ClientType {
        self.client_type.unwrap_or(ClientType::CLIENT_TYPE_WINDOWS)
    }
    pub fn clear_client_type(&mut self) {
        self.client_type = ::std::option::Option::None;
    }

    pub fn has_client_type(&self) -> bool {
        self.client_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_type(&mut self, v: ClientType) {
        self.client_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ServerUserStat {
    fn is_initialized(&self) -> bool {
        if self.user_id.is_none() {
            return false;
        }
        if self.status.is_none() {
            return false;
        }
        if self.client_type.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.user_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.client_type, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.user_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.client_type {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.user_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.status {
            os.write_enum(2, v.value())?;
        }
        if let Some(v) = self.client_type {
            os.write_enum(3, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServerUserStat {
        ServerUserStat::new()
    }

    fn default_instance() -> &'static ServerUserStat {
        static mut instance: ::protobuf::lazy::Lazy<ServerUserStat> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ServerUserStat,
        };
        unsafe {
            instance.get(ServerUserStat::new)
        }
    }
}

impl ::protobuf::Clear for ServerUserStat {
    fn clear(&mut self) {
        self.user_id = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.client_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerUserStat {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct UnreadInfo {
    // message fields
    session_id: ::std::option::Option<u32>,
    session_type: ::std::option::Option<SessionType>,
    unread_cnt: ::std::option::Option<u32>,
    latest_msg_id: ::std::option::Option<u32>,
    latest_msg_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    latest_msg_type: ::std::option::Option<MsgType>,
    latest_msg_from_user_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnreadInfo {
    fn default() -> &'a UnreadInfo {
        <UnreadInfo as ::protobuf::Message>::default_instance()
    }
}

impl UnreadInfo {
    pub fn new() -> UnreadInfo {
        ::std::default::Default::default()
    }

    // required uint32 session_id = 1;


    pub fn get_session_id(&self) -> u32 {
        self.session_id.unwrap_or(0)
    }
    pub fn clear_session_id(&mut self) {
        self.session_id = ::std::option::Option::None;
    }

    pub fn has_session_id(&self) -> bool {
        self.session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_id(&mut self, v: u32) {
        self.session_id = ::std::option::Option::Some(v);
    }

    // required .IM.BaseDefine.SessionType session_type = 2;


    pub fn get_session_type(&self) -> SessionType {
        self.session_type.unwrap_or(SessionType::SESSION_TYPE_SINGLE)
    }
    pub fn clear_session_type(&mut self) {
        self.session_type = ::std::option::Option::None;
    }

    pub fn has_session_type(&self) -> bool {
        self.session_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_type(&mut self, v: SessionType) {
        self.session_type = ::std::option::Option::Some(v);
    }

    // required uint32 unread_cnt = 3;


    pub fn get_unread_cnt(&self) -> u32 {
        self.unread_cnt.unwrap_or(0)
    }
    pub fn clear_unread_cnt(&mut self) {
        self.unread_cnt = ::std::option::Option::None;
    }

    pub fn has_unread_cnt(&self) -> bool {
        self.unread_cnt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unread_cnt(&mut self, v: u32) {
        self.unread_cnt = ::std::option::Option::Some(v);
    }

    // required uint32 latest_msg_id = 4;


    pub fn get_latest_msg_id(&self) -> u32 {
        self.latest_msg_id.unwrap_or(0)
    }
    pub fn clear_latest_msg_id(&mut self) {
        self.latest_msg_id = ::std::option::Option::None;
    }

    pub fn has_latest_msg_id(&self) -> bool {
        self.latest_msg_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_latest_msg_id(&mut self, v: u32) {
        self.latest_msg_id = ::std::option::Option::Some(v);
    }

    // required bytes latest_msg_data = 5;


    pub fn get_latest_msg_data(&self) -> &[u8] {
        match self.latest_msg_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_latest_msg_data(&mut self) {
        self.latest_msg_data.clear();
    }

    pub fn has_latest_msg_data(&self) -> bool {
        self.latest_msg_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_latest_msg_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.latest_msg_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_latest_msg_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.latest_msg_data.is_none() {
            self.latest_msg_data.set_default();
        }
        self.latest_msg_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_latest_msg_data(&mut self) -> ::std::vec::Vec<u8> {
        self.latest_msg_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required .IM.BaseDefine.MsgType latest_msg_type = 6;


    pub fn get_latest_msg_type(&self) -> MsgType {
        self.latest_msg_type.unwrap_or(MsgType::MSG_TYPE_SINGLE_TEXT)
    }
    pub fn clear_latest_msg_type(&mut self) {
        self.latest_msg_type = ::std::option::Option::None;
    }

    pub fn has_latest_msg_type(&self) -> bool {
        self.latest_msg_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_latest_msg_type(&mut self, v: MsgType) {
        self.latest_msg_type = ::std::option::Option::Some(v);
    }

    // required uint32 latest_msg_from_user_id = 7;


    pub fn get_latest_msg_from_user_id(&self) -> u32 {
        self.latest_msg_from_user_id.unwrap_or(0)
    }
    pub fn clear_latest_msg_from_user_id(&mut self) {
        self.latest_msg_from_user_id = ::std::option::Option::None;
    }

    pub fn has_latest_msg_from_user_id(&self) -> bool {
        self.latest_msg_from_user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_latest_msg_from_user_id(&mut self, v: u32) {
        self.latest_msg_from_user_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for UnreadInfo {
    fn is_initialized(&self) -> bool {
        if self.session_id.is_none() {
            return false;
        }
        if self.session_type.is_none() {
            return false;
        }
        if self.unread_cnt.is_none() {
            return false;
        }
        if self.latest_msg_id.is_none() {
            return false;
        }
        if self.latest_msg_data.is_none() {
            return false;
        }
        if self.latest_msg_type.is_none() {
            return false;
        }
        if self.latest_msg_from_user_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.session_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.session_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.unread_cnt = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.latest_msg_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.latest_msg_data)?;
                },
                6 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.latest_msg_type, 6, &mut self.unknown_fields)?
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.latest_msg_from_user_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.session_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.session_type {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.unread_cnt {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.latest_msg_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.latest_msg_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.latest_msg_type {
            my_size += ::protobuf::rt::enum_size(6, v);
        }
        if let Some(v) = self.latest_msg_from_user_id {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.session_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.session_type {
            os.write_enum(2, v.value())?;
        }
        if let Some(v) = self.unread_cnt {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.latest_msg_id {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.latest_msg_data.as_ref() {
            os.write_bytes(5, &v)?;
        }
        if let Some(v) = self.latest_msg_type {
            os.write_enum(6, v.value())?;
        }
        if let Some(v) = self.latest_msg_from_user_id {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnreadInfo {
        UnreadInfo::new()
    }

    fn default_instance() -> &'static UnreadInfo {
        static mut instance: ::protobuf::lazy::Lazy<UnreadInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UnreadInfo,
        };
        unsafe {
            instance.get(UnreadInfo::new)
        }
    }
}

impl ::protobuf::Clear for UnreadInfo {
    fn clear(&mut self) {
        self.session_id = ::std::option::Option::None;
        self.session_type = ::std::option::Option::None;
        self.unread_cnt = ::std::option::Option::None;
        self.latest_msg_id = ::std::option::Option::None;
        self.latest_msg_data.clear();
        self.latest_msg_type = ::std::option::Option::None;
        self.latest_msg_from_user_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for UnreadInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgInfo {
    // message fields
    msg_id: ::std::option::Option<u32>,
    from_session_id: ::std::option::Option<u32>,
    create_time: ::std::option::Option<u32>,
    msg_type: ::std::option::Option<MsgType>,
    msg_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgInfo {
    fn default() -> &'a MsgInfo {
        <MsgInfo as ::protobuf::Message>::default_instance()
    }
}

impl MsgInfo {
    pub fn new() -> MsgInfo {
        ::std::default::Default::default()
    }

    // required uint32 msg_id = 1;


    pub fn get_msg_id(&self) -> u32 {
        self.msg_id.unwrap_or(0)
    }
    pub fn clear_msg_id(&mut self) {
        self.msg_id = ::std::option::Option::None;
    }

    pub fn has_msg_id(&self) -> bool {
        self.msg_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_id(&mut self, v: u32) {
        self.msg_id = ::std::option::Option::Some(v);
    }

    // required uint32 from_session_id = 2;


    pub fn get_from_session_id(&self) -> u32 {
        self.from_session_id.unwrap_or(0)
    }
    pub fn clear_from_session_id(&mut self) {
        self.from_session_id = ::std::option::Option::None;
    }

    pub fn has_from_session_id(&self) -> bool {
        self.from_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_session_id(&mut self, v: u32) {
        self.from_session_id = ::std::option::Option::Some(v);
    }

    // required uint32 create_time = 3;


    pub fn get_create_time(&self) -> u32 {
        self.create_time.unwrap_or(0)
    }
    pub fn clear_create_time(&mut self) {
        self.create_time = ::std::option::Option::None;
    }

    pub fn has_create_time(&self) -> bool {
        self.create_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_time(&mut self, v: u32) {
        self.create_time = ::std::option::Option::Some(v);
    }

    // required .IM.BaseDefine.MsgType msg_type = 4;


    pub fn get_msg_type(&self) -> MsgType {
        self.msg_type.unwrap_or(MsgType::MSG_TYPE_SINGLE_TEXT)
    }
    pub fn clear_msg_type(&mut self) {
        self.msg_type = ::std::option::Option::None;
    }

    pub fn has_msg_type(&self) -> bool {
        self.msg_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_type(&mut self, v: MsgType) {
        self.msg_type = ::std::option::Option::Some(v);
    }

    // required bytes msg_data = 5;


    pub fn get_msg_data(&self) -> &[u8] {
        match self.msg_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_msg_data(&mut self) {
        self.msg_data.clear();
    }

    pub fn has_msg_data(&self) -> bool {
        self.msg_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.msg_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_msg_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.msg_data.is_none() {
            self.msg_data.set_default();
        }
        self.msg_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_msg_data(&mut self) -> ::std::vec::Vec<u8> {
        self.msg_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MsgInfo {
    fn is_initialized(&self) -> bool {
        if self.msg_id.is_none() {
            return false;
        }
        if self.from_session_id.is_none() {
            return false;
        }
        if self.create_time.is_none() {
            return false;
        }
        if self.msg_type.is_none() {
            return false;
        }
        if self.msg_data.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.msg_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.from_session_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.create_time = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.msg_type, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.msg_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.msg_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.from_session_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.create_time {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.msg_type {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(ref v) = self.msg_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.msg_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.from_session_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.create_time {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.msg_type {
            os.write_enum(4, v.value())?;
        }
        if let Some(ref v) = self.msg_data.as_ref() {
            os.write_bytes(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgInfo {
        MsgInfo::new()
    }

    fn default_instance() -> &'static MsgInfo {
        static mut instance: ::protobuf::lazy::Lazy<MsgInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MsgInfo,
        };
        unsafe {
            instance.get(MsgInfo::new)
        }
    }
}

impl ::protobuf::Clear for MsgInfo {
    fn clear(&mut self) {
        self.msg_id = ::std::option::Option::None;
        self.from_session_id = ::std::option::Option::None;
        self.create_time = ::std::option::Option::None;
        self.msg_type = ::std::option::Option::None;
        self.msg_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GroupVersionInfo {
    // message fields
    group_id: ::std::option::Option<u32>,
    version: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupVersionInfo {
    fn default() -> &'a GroupVersionInfo {
        <GroupVersionInfo as ::protobuf::Message>::default_instance()
    }
}

impl GroupVersionInfo {
    pub fn new() -> GroupVersionInfo {
        ::std::default::Default::default()
    }

    // required uint32 group_id = 1;


    pub fn get_group_id(&self) -> u32 {
        self.group_id.unwrap_or(0)
    }
    pub fn clear_group_id(&mut self) {
        self.group_id = ::std::option::Option::None;
    }

    pub fn has_group_id(&self) -> bool {
        self.group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_id(&mut self, v: u32) {
        self.group_id = ::std::option::Option::Some(v);
    }

    // required uint32 version = 2;


    pub fn get_version(&self) -> u32 {
        self.version.unwrap_or(0)
    }
    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GroupVersionInfo {
    fn is_initialized(&self) -> bool {
        if self.group_id.is_none() {
            return false;
        }
        if self.version.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.group_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.version {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupVersionInfo {
        GroupVersionInfo::new()
    }

    fn default_instance() -> &'static GroupVersionInfo {
        static mut instance: ::protobuf::lazy::Lazy<GroupVersionInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GroupVersionInfo,
        };
        unsafe {
            instance.get(GroupVersionInfo::new)
        }
    }
}

impl ::protobuf::Clear for GroupVersionInfo {
    fn clear(&mut self) {
        self.group_id = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupVersionInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GroupInfo {
    // message fields
    group_id: ::std::option::Option<u32>,
    version: ::std::option::Option<u32>,
    group_name: ::protobuf::SingularField<::std::string::String>,
    group_avatar: ::protobuf::SingularField<::std::string::String>,
    group_creator_id: ::std::option::Option<u32>,
    group_type: ::std::option::Option<GroupType>,
    shield_status: ::std::option::Option<u32>,
    group_member_list: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupInfo {
    fn default() -> &'a GroupInfo {
        <GroupInfo as ::protobuf::Message>::default_instance()
    }
}

impl GroupInfo {
    pub fn new() -> GroupInfo {
        ::std::default::Default::default()
    }

    // required uint32 group_id = 1;


    pub fn get_group_id(&self) -> u32 {
        self.group_id.unwrap_or(0)
    }
    pub fn clear_group_id(&mut self) {
        self.group_id = ::std::option::Option::None;
    }

    pub fn has_group_id(&self) -> bool {
        self.group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_id(&mut self, v: u32) {
        self.group_id = ::std::option::Option::Some(v);
    }

    // required uint32 version = 2;


    pub fn get_version(&self) -> u32 {
        self.version.unwrap_or(0)
    }
    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // required string group_name = 3;


    pub fn get_group_name(&self) -> &str {
        match self.group_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_group_name(&mut self) {
        self.group_name.clear();
    }

    pub fn has_group_name(&self) -> bool {
        self.group_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_name(&mut self, v: ::std::string::String) {
        self.group_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group_name(&mut self) -> &mut ::std::string::String {
        if self.group_name.is_none() {
            self.group_name.set_default();
        }
        self.group_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_group_name(&mut self) -> ::std::string::String {
        self.group_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string group_avatar = 4;


    pub fn get_group_avatar(&self) -> &str {
        match self.group_avatar.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_group_avatar(&mut self) {
        self.group_avatar.clear();
    }

    pub fn has_group_avatar(&self) -> bool {
        self.group_avatar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_avatar(&mut self, v: ::std::string::String) {
        self.group_avatar = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group_avatar(&mut self) -> &mut ::std::string::String {
        if self.group_avatar.is_none() {
            self.group_avatar.set_default();
        }
        self.group_avatar.as_mut().unwrap()
    }

    // Take field
    pub fn take_group_avatar(&mut self) -> ::std::string::String {
        self.group_avatar.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint32 group_creator_id = 5;


    pub fn get_group_creator_id(&self) -> u32 {
        self.group_creator_id.unwrap_or(0)
    }
    pub fn clear_group_creator_id(&mut self) {
        self.group_creator_id = ::std::option::Option::None;
    }

    pub fn has_group_creator_id(&self) -> bool {
        self.group_creator_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_creator_id(&mut self, v: u32) {
        self.group_creator_id = ::std::option::Option::Some(v);
    }

    // required .IM.BaseDefine.GroupType group_type = 6;


    pub fn get_group_type(&self) -> GroupType {
        self.group_type.unwrap_or(GroupType::GROUP_TYPE_NORMAL)
    }
    pub fn clear_group_type(&mut self) {
        self.group_type = ::std::option::Option::None;
    }

    pub fn has_group_type(&self) -> bool {
        self.group_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_type(&mut self, v: GroupType) {
        self.group_type = ::std::option::Option::Some(v);
    }

    // required uint32 shield_status = 7;


    pub fn get_shield_status(&self) -> u32 {
        self.shield_status.unwrap_or(0)
    }
    pub fn clear_shield_status(&mut self) {
        self.shield_status = ::std::option::Option::None;
    }

    pub fn has_shield_status(&self) -> bool {
        self.shield_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shield_status(&mut self, v: u32) {
        self.shield_status = ::std::option::Option::Some(v);
    }

    // repeated uint32 group_member_list = 8;


    pub fn get_group_member_list(&self) -> &[u32] {
        &self.group_member_list
    }
    pub fn clear_group_member_list(&mut self) {
        self.group_member_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_group_member_list(&mut self, v: ::std::vec::Vec<u32>) {
        self.group_member_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_group_member_list(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.group_member_list
    }

    // Take field
    pub fn take_group_member_list(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.group_member_list, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GroupInfo {
    fn is_initialized(&self) -> bool {
        if self.group_id.is_none() {
            return false;
        }
        if self.version.is_none() {
            return false;
        }
        if self.group_name.is_none() {
            return false;
        }
        if self.group_avatar.is_none() {
            return false;
        }
        if self.group_creator_id.is_none() {
            return false;
        }
        if self.group_type.is_none() {
            return false;
        }
        if self.shield_status.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.group_name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.group_avatar)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.group_creator_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.group_type, 6, &mut self.unknown_fields)?
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.shield_status = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.group_member_list)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.group_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.group_avatar.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.group_creator_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.group_type {
            my_size += ::protobuf::rt::enum_size(6, v);
        }
        if let Some(v) = self.shield_status {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.group_member_list {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.group_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.version {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.group_name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.group_avatar.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.group_creator_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.group_type {
            os.write_enum(6, v.value())?;
        }
        if let Some(v) = self.shield_status {
            os.write_uint32(7, v)?;
        }
        for v in &self.group_member_list {
            os.write_uint32(8, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupInfo {
        GroupInfo::new()
    }

    fn default_instance() -> &'static GroupInfo {
        static mut instance: ::protobuf::lazy::Lazy<GroupInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GroupInfo,
        };
        unsafe {
            instance.get(GroupInfo::new)
        }
    }
}

impl ::protobuf::Clear for GroupInfo {
    fn clear(&mut self) {
        self.group_id = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.group_name.clear();
        self.group_avatar.clear();
        self.group_creator_id = ::std::option::Option::None;
        self.group_type = ::std::option::Option::None;
        self.shield_status = ::std::option::Option::None;
        self.group_member_list.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct UserTokenInfo {
    // message fields
    user_id: ::std::option::Option<u32>,
    user_type: ::std::option::Option<ClientType>,
    token: ::protobuf::SingularField<::std::string::String>,
    push_count: ::std::option::Option<u32>,
    push_type: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserTokenInfo {
    fn default() -> &'a UserTokenInfo {
        <UserTokenInfo as ::protobuf::Message>::default_instance()
    }
}

impl UserTokenInfo {
    pub fn new() -> UserTokenInfo {
        ::std::default::Default::default()
    }

    // required uint32 user_id = 1;


    pub fn get_user_id(&self) -> u32 {
        self.user_id.unwrap_or(0)
    }
    pub fn clear_user_id(&mut self) {
        self.user_id = ::std::option::Option::None;
    }

    pub fn has_user_id(&self) -> bool {
        self.user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: u32) {
        self.user_id = ::std::option::Option::Some(v);
    }

    // required .IM.BaseDefine.ClientType user_type = 2;


    pub fn get_user_type(&self) -> ClientType {
        self.user_type.unwrap_or(ClientType::CLIENT_TYPE_WINDOWS)
    }
    pub fn clear_user_type(&mut self) {
        self.user_type = ::std::option::Option::None;
    }

    pub fn has_user_type(&self) -> bool {
        self.user_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_type(&mut self, v: ClientType) {
        self.user_type = ::std::option::Option::Some(v);
    }

    // required string token = 3;


    pub fn get_token(&self) -> &str {
        match self.token.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::string::String) {
        self.token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::string::String {
        if self.token.is_none() {
            self.token.set_default();
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::string::String {
        self.token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint32 push_count = 4;


    pub fn get_push_count(&self) -> u32 {
        self.push_count.unwrap_or(0)
    }
    pub fn clear_push_count(&mut self) {
        self.push_count = ::std::option::Option::None;
    }

    pub fn has_push_count(&self) -> bool {
        self.push_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_push_count(&mut self, v: u32) {
        self.push_count = ::std::option::Option::Some(v);
    }

    // required uint32 push_type = 5;


    pub fn get_push_type(&self) -> u32 {
        self.push_type.unwrap_or(0)
    }
    pub fn clear_push_type(&mut self) {
        self.push_type = ::std::option::Option::None;
    }

    pub fn has_push_type(&self) -> bool {
        self.push_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_push_type(&mut self, v: u32) {
        self.push_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for UserTokenInfo {
    fn is_initialized(&self) -> bool {
        if self.user_id.is_none() {
            return false;
        }
        if self.user_type.is_none() {
            return false;
        }
        if self.token.is_none() {
            return false;
        }
        if self.push_count.is_none() {
            return false;
        }
        if self.push_type.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.user_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.user_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.token)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.push_count = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.push_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.user_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.user_type {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(ref v) = self.token.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.push_count {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.push_type {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.user_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.user_type {
            os.write_enum(2, v.value())?;
        }
        if let Some(ref v) = self.token.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.push_count {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.push_type {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserTokenInfo {
        UserTokenInfo::new()
    }

    fn default_instance() -> &'static UserTokenInfo {
        static mut instance: ::protobuf::lazy::Lazy<UserTokenInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UserTokenInfo,
        };
        unsafe {
            instance.get(UserTokenInfo::new)
        }
    }
}

impl ::protobuf::Clear for UserTokenInfo {
    fn clear(&mut self) {
        self.user_id = ::std::option::Option::None;
        self.user_type = ::std::option::Option::None;
        self.token.clear();
        self.push_count = ::std::option::Option::None;
        self.push_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for UserTokenInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct PushResult {
    // message fields
    user_token: ::protobuf::SingularField<::std::string::String>,
    result_code: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PushResult {
    fn default() -> &'a PushResult {
        <PushResult as ::protobuf::Message>::default_instance()
    }
}

impl PushResult {
    pub fn new() -> PushResult {
        ::std::default::Default::default()
    }

    // required string user_token = 1;


    pub fn get_user_token(&self) -> &str {
        match self.user_token.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_user_token(&mut self) {
        self.user_token.clear();
    }

    pub fn has_user_token(&self) -> bool {
        self.user_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_token(&mut self, v: ::std::string::String) {
        self.user_token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_token(&mut self) -> &mut ::std::string::String {
        if self.user_token.is_none() {
            self.user_token.set_default();
        }
        self.user_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_token(&mut self) -> ::std::string::String {
        self.user_token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint32 result_code = 2;


    pub fn get_result_code(&self) -> u32 {
        self.result_code.unwrap_or(0)
    }
    pub fn clear_result_code(&mut self) {
        self.result_code = ::std::option::Option::None;
    }

    pub fn has_result_code(&self) -> bool {
        self.result_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result_code(&mut self, v: u32) {
        self.result_code = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PushResult {
    fn is_initialized(&self) -> bool {
        if self.user_token.is_none() {
            return false;
        }
        if self.result_code.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.user_token)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.result_code = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_token.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.result_code {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_token.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.result_code {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PushResult {
        PushResult::new()
    }

    fn default_instance() -> &'static PushResult {
        static mut instance: ::protobuf::lazy::Lazy<PushResult> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PushResult,
        };
        unsafe {
            instance.get(PushResult::new)
        }
    }
}

impl ::protobuf::Clear for PushResult {
    fn clear(&mut self) {
        self.user_token.clear();
        self.result_code = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for PushResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct ShieldStatus {
    // message fields
    user_id: ::std::option::Option<u32>,
    group_id: ::std::option::Option<u32>,
    shield_status: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ShieldStatus {
    fn default() -> &'a ShieldStatus {
        <ShieldStatus as ::protobuf::Message>::default_instance()
    }
}

impl ShieldStatus {
    pub fn new() -> ShieldStatus {
        ::std::default::Default::default()
    }

    // required uint32 user_id = 1;


    pub fn get_user_id(&self) -> u32 {
        self.user_id.unwrap_or(0)
    }
    pub fn clear_user_id(&mut self) {
        self.user_id = ::std::option::Option::None;
    }

    pub fn has_user_id(&self) -> bool {
        self.user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: u32) {
        self.user_id = ::std::option::Option::Some(v);
    }

    // required uint32 group_id = 2;


    pub fn get_group_id(&self) -> u32 {
        self.group_id.unwrap_or(0)
    }
    pub fn clear_group_id(&mut self) {
        self.group_id = ::std::option::Option::None;
    }

    pub fn has_group_id(&self) -> bool {
        self.group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_id(&mut self, v: u32) {
        self.group_id = ::std::option::Option::Some(v);
    }

    // required uint32 shield_status = 3;


    pub fn get_shield_status(&self) -> u32 {
        self.shield_status.unwrap_or(0)
    }
    pub fn clear_shield_status(&mut self) {
        self.shield_status = ::std::option::Option::None;
    }

    pub fn has_shield_status(&self) -> bool {
        self.shield_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shield_status(&mut self, v: u32) {
        self.shield_status = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ShieldStatus {
    fn is_initialized(&self) -> bool {
        if self.user_id.is_none() {
            return false;
        }
        if self.group_id.is_none() {
            return false;
        }
        if self.shield_status.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.user_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.group_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.shield_status = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.user_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.group_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.shield_status {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.user_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.group_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.shield_status {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ShieldStatus {
        ShieldStatus::new()
    }

    fn default_instance() -> &'static ShieldStatus {
        static mut instance: ::protobuf::lazy::Lazy<ShieldStatus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ShieldStatus,
        };
        unsafe {
            instance.get(ShieldStatus::new)
        }
    }
}

impl ::protobuf::Clear for ShieldStatus {
    fn clear(&mut self) {
        self.user_id = ::std::option::Option::None;
        self.group_id = ::std::option::Option::None;
        self.shield_status = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for ShieldStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct OfflineFileInfo {
    // message fields
    from_user_id: ::std::option::Option<u32>,
    task_id: ::protobuf::SingularField<::std::string::String>,
    file_name: ::protobuf::SingularField<::std::string::String>,
    file_size: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OfflineFileInfo {
    fn default() -> &'a OfflineFileInfo {
        <OfflineFileInfo as ::protobuf::Message>::default_instance()
    }
}

impl OfflineFileInfo {
    pub fn new() -> OfflineFileInfo {
        ::std::default::Default::default()
    }

    // required uint32 from_user_id = 1;


    pub fn get_from_user_id(&self) -> u32 {
        self.from_user_id.unwrap_or(0)
    }
    pub fn clear_from_user_id(&mut self) {
        self.from_user_id = ::std::option::Option::None;
    }

    pub fn has_from_user_id(&self) -> bool {
        self.from_user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_user_id(&mut self, v: u32) {
        self.from_user_id = ::std::option::Option::Some(v);
    }

    // required string task_id = 2;


    pub fn get_task_id(&self) -> &str {
        match self.task_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_task_id(&mut self) {
        self.task_id.clear();
    }

    pub fn has_task_id(&self) -> bool {
        self.task_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_task_id(&mut self, v: ::std::string::String) {
        self.task_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_task_id(&mut self) -> &mut ::std::string::String {
        if self.task_id.is_none() {
            self.task_id.set_default();
        }
        self.task_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_task_id(&mut self) -> ::std::string::String {
        self.task_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string file_name = 3;


    pub fn get_file_name(&self) -> &str {
        match self.file_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_file_name(&mut self) {
        self.file_name.clear();
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name.set_default();
        }
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint32 file_size = 4;


    pub fn get_file_size(&self) -> u32 {
        self.file_size.unwrap_or(0)
    }
    pub fn clear_file_size(&mut self) {
        self.file_size = ::std::option::Option::None;
    }

    pub fn has_file_size(&self) -> bool {
        self.file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_size(&mut self, v: u32) {
        self.file_size = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for OfflineFileInfo {
    fn is_initialized(&self) -> bool {
        if self.from_user_id.is_none() {
            return false;
        }
        if self.task_id.is_none() {
            return false;
        }
        if self.file_name.is_none() {
            return false;
        }
        if self.file_size.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.from_user_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.task_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.file_size = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.from_user_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.task_id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.file_size {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.from_user_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.task_id.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.file_name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.file_size {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OfflineFileInfo {
        OfflineFileInfo::new()
    }

    fn default_instance() -> &'static OfflineFileInfo {
        static mut instance: ::protobuf::lazy::Lazy<OfflineFileInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OfflineFileInfo,
        };
        unsafe {
            instance.get(OfflineFileInfo::new)
        }
    }
}

impl ::protobuf::Clear for OfflineFileInfo {
    fn clear(&mut self) {
        self.from_user_id = ::std::option::Option::None;
        self.task_id.clear();
        self.file_name.clear();
        self.file_size = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for OfflineFileInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct DepartInfo {
    // message fields
    dept_id: ::std::option::Option<u32>,
    priority: ::std::option::Option<u32>,
    dept_name: ::protobuf::SingularField<::std::string::String>,
    parent_dept_id: ::std::option::Option<u32>,
    dept_status: ::std::option::Option<DepartmentStatusType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DepartInfo {
    fn default() -> &'a DepartInfo {
        <DepartInfo as ::protobuf::Message>::default_instance()
    }
}

impl DepartInfo {
    pub fn new() -> DepartInfo {
        ::std::default::Default::default()
    }

    // required uint32 dept_id = 1;


    pub fn get_dept_id(&self) -> u32 {
        self.dept_id.unwrap_or(0)
    }
    pub fn clear_dept_id(&mut self) {
        self.dept_id = ::std::option::Option::None;
    }

    pub fn has_dept_id(&self) -> bool {
        self.dept_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dept_id(&mut self, v: u32) {
        self.dept_id = ::std::option::Option::Some(v);
    }

    // required uint32 priority = 2;


    pub fn get_priority(&self) -> u32 {
        self.priority.unwrap_or(0)
    }
    pub fn clear_priority(&mut self) {
        self.priority = ::std::option::Option::None;
    }

    pub fn has_priority(&self) -> bool {
        self.priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_priority(&mut self, v: u32) {
        self.priority = ::std::option::Option::Some(v);
    }

    // required string dept_name = 3;


    pub fn get_dept_name(&self) -> &str {
        match self.dept_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_dept_name(&mut self) {
        self.dept_name.clear();
    }

    pub fn has_dept_name(&self) -> bool {
        self.dept_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dept_name(&mut self, v: ::std::string::String) {
        self.dept_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dept_name(&mut self) -> &mut ::std::string::String {
        if self.dept_name.is_none() {
            self.dept_name.set_default();
        }
        self.dept_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_dept_name(&mut self) -> ::std::string::String {
        self.dept_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint32 parent_dept_id = 4;


    pub fn get_parent_dept_id(&self) -> u32 {
        self.parent_dept_id.unwrap_or(0)
    }
    pub fn clear_parent_dept_id(&mut self) {
        self.parent_dept_id = ::std::option::Option::None;
    }

    pub fn has_parent_dept_id(&self) -> bool {
        self.parent_dept_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent_dept_id(&mut self, v: u32) {
        self.parent_dept_id = ::std::option::Option::Some(v);
    }

    // required .IM.BaseDefine.DepartmentStatusType dept_status = 5;


    pub fn get_dept_status(&self) -> DepartmentStatusType {
        self.dept_status.unwrap_or(DepartmentStatusType::DEPT_STATUS_OK)
    }
    pub fn clear_dept_status(&mut self) {
        self.dept_status = ::std::option::Option::None;
    }

    pub fn has_dept_status(&self) -> bool {
        self.dept_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dept_status(&mut self, v: DepartmentStatusType) {
        self.dept_status = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DepartInfo {
    fn is_initialized(&self) -> bool {
        if self.dept_id.is_none() {
            return false;
        }
        if self.priority.is_none() {
            return false;
        }
        if self.dept_name.is_none() {
            return false;
        }
        if self.parent_dept_id.is_none() {
            return false;
        }
        if self.dept_status.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dept_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.priority = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.dept_name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.parent_dept_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.dept_status, 5, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.dept_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.priority {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.dept_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.parent_dept_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dept_status {
            my_size += ::protobuf::rt::enum_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.dept_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.priority {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.dept_name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.parent_dept_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.dept_status {
            os.write_enum(5, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DepartInfo {
        DepartInfo::new()
    }

    fn default_instance() -> &'static DepartInfo {
        static mut instance: ::protobuf::lazy::Lazy<DepartInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DepartInfo,
        };
        unsafe {
            instance.get(DepartInfo::new)
        }
    }
}

impl ::protobuf::Clear for DepartInfo {
    fn clear(&mut self) {
        self.dept_id = ::std::option::Option::None;
        self.priority = ::std::option::Option::None;
        self.dept_name.clear();
        self.parent_dept_id = ::std::option::Option::None;
        self.dept_status = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for DepartInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct PushShieldStatus {
    // message fields
    user_id: ::std::option::Option<u32>,
    shield_status: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PushShieldStatus {
    fn default() -> &'a PushShieldStatus {
        <PushShieldStatus as ::protobuf::Message>::default_instance()
    }
}

impl PushShieldStatus {
    pub fn new() -> PushShieldStatus {
        ::std::default::Default::default()
    }

    // required uint32 user_id = 1;


    pub fn get_user_id(&self) -> u32 {
        self.user_id.unwrap_or(0)
    }
    pub fn clear_user_id(&mut self) {
        self.user_id = ::std::option::Option::None;
    }

    pub fn has_user_id(&self) -> bool {
        self.user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: u32) {
        self.user_id = ::std::option::Option::Some(v);
    }

    // required uint32 shield_status = 2;


    pub fn get_shield_status(&self) -> u32 {
        self.shield_status.unwrap_or(0)
    }
    pub fn clear_shield_status(&mut self) {
        self.shield_status = ::std::option::Option::None;
    }

    pub fn has_shield_status(&self) -> bool {
        self.shield_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shield_status(&mut self, v: u32) {
        self.shield_status = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PushShieldStatus {
    fn is_initialized(&self) -> bool {
        if self.user_id.is_none() {
            return false;
        }
        if self.shield_status.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.user_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.shield_status = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.user_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.shield_status {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.user_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.shield_status {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PushShieldStatus {
        PushShieldStatus::new()
    }

    fn default_instance() -> &'static PushShieldStatus {
        static mut instance: ::protobuf::lazy::Lazy<PushShieldStatus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PushShieldStatus,
        };
        unsafe {
            instance.get(PushShieldStatus::new)
        }
    }
}

impl ::protobuf::Clear for PushShieldStatus {
    fn clear(&mut self) {
        self.user_id = ::std::option::Option::None;
        self.shield_status = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for PushShieldStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ServiceID {
    SID_LOGIN = 1,
    SID_BUDDY_LIST = 2,
    SID_MSG = 3,
    SID_GROUP = 4,
    SID_FILE = 5,
    SID_SWITCH_SERVICE = 6,
    SID_OTHER = 7,
    SID_INTERNAL = 8,
}

impl ::protobuf::ProtobufEnum for ServiceID {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ServiceID> {
        match value {
            1 => ::std::option::Option::Some(ServiceID::SID_LOGIN),
            2 => ::std::option::Option::Some(ServiceID::SID_BUDDY_LIST),
            3 => ::std::option::Option::Some(ServiceID::SID_MSG),
            4 => ::std::option::Option::Some(ServiceID::SID_GROUP),
            5 => ::std::option::Option::Some(ServiceID::SID_FILE),
            6 => ::std::option::Option::Some(ServiceID::SID_SWITCH_SERVICE),
            7 => ::std::option::Option::Some(ServiceID::SID_OTHER),
            8 => ::std::option::Option::Some(ServiceID::SID_INTERNAL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ServiceID] = &[
            ServiceID::SID_LOGIN,
            ServiceID::SID_BUDDY_LIST,
            ServiceID::SID_MSG,
            ServiceID::SID_GROUP,
            ServiceID::SID_FILE,
            ServiceID::SID_SWITCH_SERVICE,
            ServiceID::SID_OTHER,
            ServiceID::SID_INTERNAL,
        ];
        values
    }
}

impl ::std::marker::Copy for ServiceID {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ServiceID {
    fn default() -> Self {
        ServiceID::SID_LOGIN
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceID {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum LoginCmdID {
    CID_LOGIN_REQ_MSGSERVER = 257,
    CID_LOGIN_RES_MSGSERVER = 258,
    CID_LOGIN_REQ_USERLOGIN = 259,
    CID_LOGIN_RES_USERLOGIN = 260,
    CID_LOGIN_REQ_LOGINOUT = 261,
    CID_LOGIN_RES_LOGINOUT = 262,
    CID_LOGIN_KICK_USER = 263,
    CID_LOGIN_REQ_DEVICETOKEN = 264,
    CID_LOGIN_RES_DEVICETOKEN = 265,
    CID_LOGIN_REQ_KICKPCCLIENT = 266,
    CID_LOGIN_RES_KICKPCCLIENT = 267,
    CID_LOGIN_REQ_PUSH_SHIELD = 268,
    CID_LOGIN_RES_PUSH_SHIELD = 269,
    CID_LOGIN_REQ_QUERY_PUSH_SHIELD = 270,
    CID_LOGIN_RES_QUERY_PUSH_SHIELD = 271,
}

impl ::protobuf::ProtobufEnum for LoginCmdID {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LoginCmdID> {
        match value {
            257 => ::std::option::Option::Some(LoginCmdID::CID_LOGIN_REQ_MSGSERVER),
            258 => ::std::option::Option::Some(LoginCmdID::CID_LOGIN_RES_MSGSERVER),
            259 => ::std::option::Option::Some(LoginCmdID::CID_LOGIN_REQ_USERLOGIN),
            260 => ::std::option::Option::Some(LoginCmdID::CID_LOGIN_RES_USERLOGIN),
            261 => ::std::option::Option::Some(LoginCmdID::CID_LOGIN_REQ_LOGINOUT),
            262 => ::std::option::Option::Some(LoginCmdID::CID_LOGIN_RES_LOGINOUT),
            263 => ::std::option::Option::Some(LoginCmdID::CID_LOGIN_KICK_USER),
            264 => ::std::option::Option::Some(LoginCmdID::CID_LOGIN_REQ_DEVICETOKEN),
            265 => ::std::option::Option::Some(LoginCmdID::CID_LOGIN_RES_DEVICETOKEN),
            266 => ::std::option::Option::Some(LoginCmdID::CID_LOGIN_REQ_KICKPCCLIENT),
            267 => ::std::option::Option::Some(LoginCmdID::CID_LOGIN_RES_KICKPCCLIENT),
            268 => ::std::option::Option::Some(LoginCmdID::CID_LOGIN_REQ_PUSH_SHIELD),
            269 => ::std::option::Option::Some(LoginCmdID::CID_LOGIN_RES_PUSH_SHIELD),
            270 => ::std::option::Option::Some(LoginCmdID::CID_LOGIN_REQ_QUERY_PUSH_SHIELD),
            271 => ::std::option::Option::Some(LoginCmdID::CID_LOGIN_RES_QUERY_PUSH_SHIELD),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [LoginCmdID] = &[
            LoginCmdID::CID_LOGIN_REQ_MSGSERVER,
            LoginCmdID::CID_LOGIN_RES_MSGSERVER,
            LoginCmdID::CID_LOGIN_REQ_USERLOGIN,
            LoginCmdID::CID_LOGIN_RES_USERLOGIN,
            LoginCmdID::CID_LOGIN_REQ_LOGINOUT,
            LoginCmdID::CID_LOGIN_RES_LOGINOUT,
            LoginCmdID::CID_LOGIN_KICK_USER,
            LoginCmdID::CID_LOGIN_REQ_DEVICETOKEN,
            LoginCmdID::CID_LOGIN_RES_DEVICETOKEN,
            LoginCmdID::CID_LOGIN_REQ_KICKPCCLIENT,
            LoginCmdID::CID_LOGIN_RES_KICKPCCLIENT,
            LoginCmdID::CID_LOGIN_REQ_PUSH_SHIELD,
            LoginCmdID::CID_LOGIN_RES_PUSH_SHIELD,
            LoginCmdID::CID_LOGIN_REQ_QUERY_PUSH_SHIELD,
            LoginCmdID::CID_LOGIN_RES_QUERY_PUSH_SHIELD,
        ];
        values
    }
}

impl ::std::marker::Copy for LoginCmdID {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for LoginCmdID {
    fn default() -> Self {
        LoginCmdID::CID_LOGIN_REQ_MSGSERVER
    }
}

impl ::protobuf::reflect::ProtobufValue for LoginCmdID {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum BuddyListCmdID {
    CID_BUDDY_LIST_RECENT_CONTACT_SESSION_REQUEST = 513,
    CID_BUDDY_LIST_RECENT_CONTACT_SESSION_RESPONSE = 514,
    CID_BUDDY_LIST_STATUS_NOTIFY = 515,
    CID_BUDDY_LIST_USER_INFO_REQUEST = 516,
    CID_BUDDY_LIST_USER_INFO_RESPONSE = 517,
    CID_BUDDY_LIST_REMOVE_SESSION_REQ = 518,
    CID_BUDDY_LIST_REMOVE_SESSION_RES = 519,
    CID_BUDDY_LIST_ALL_USER_REQUEST = 520,
    CID_BUDDY_LIST_ALL_USER_RESPONSE = 521,
    CID_BUDDY_LIST_USERS_STATUS_REQUEST = 522,
    CID_BUDDY_LIST_USERS_STATUS_RESPONSE = 523,
    CID_BUDDY_LIST_CHANGE_AVATAR_REQUEST = 524,
    CID_BUDDY_LIST_CHANGE_AVATAR_RESPONSE = 525,
    CID_BUDDY_LIST_PC_LOGIN_STATUS_NOTIFY = 526,
    CID_BUDDY_LIST_REMOVE_SESSION_NOTIFY = 527,
    CID_BUDDY_LIST_DEPARTMENT_REQUEST = 528,
    CID_BUDDY_LIST_DEPARTMENT_RESPONSE = 529,
    CID_BUDDY_LIST_AVATAR_CHANGED_NOTIFY = 530,
    CID_BUDDY_LIST_CHANGE_SIGN_INFO_REQUEST = 531,
    CID_BUDDY_LIST_CHANGE_SIGN_INFO_RESPONSE = 532,
    CID_BUDDY_LIST_SIGN_INFO_CHANGED_NOTIFY = 533,
}

impl ::protobuf::ProtobufEnum for BuddyListCmdID {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BuddyListCmdID> {
        match value {
            513 => ::std::option::Option::Some(BuddyListCmdID::CID_BUDDY_LIST_RECENT_CONTACT_SESSION_REQUEST),
            514 => ::std::option::Option::Some(BuddyListCmdID::CID_BUDDY_LIST_RECENT_CONTACT_SESSION_RESPONSE),
            515 => ::std::option::Option::Some(BuddyListCmdID::CID_BUDDY_LIST_STATUS_NOTIFY),
            516 => ::std::option::Option::Some(BuddyListCmdID::CID_BUDDY_LIST_USER_INFO_REQUEST),
            517 => ::std::option::Option::Some(BuddyListCmdID::CID_BUDDY_LIST_USER_INFO_RESPONSE),
            518 => ::std::option::Option::Some(BuddyListCmdID::CID_BUDDY_LIST_REMOVE_SESSION_REQ),
            519 => ::std::option::Option::Some(BuddyListCmdID::CID_BUDDY_LIST_REMOVE_SESSION_RES),
            520 => ::std::option::Option::Some(BuddyListCmdID::CID_BUDDY_LIST_ALL_USER_REQUEST),
            521 => ::std::option::Option::Some(BuddyListCmdID::CID_BUDDY_LIST_ALL_USER_RESPONSE),
            522 => ::std::option::Option::Some(BuddyListCmdID::CID_BUDDY_LIST_USERS_STATUS_REQUEST),
            523 => ::std::option::Option::Some(BuddyListCmdID::CID_BUDDY_LIST_USERS_STATUS_RESPONSE),
            524 => ::std::option::Option::Some(BuddyListCmdID::CID_BUDDY_LIST_CHANGE_AVATAR_REQUEST),
            525 => ::std::option::Option::Some(BuddyListCmdID::CID_BUDDY_LIST_CHANGE_AVATAR_RESPONSE),
            526 => ::std::option::Option::Some(BuddyListCmdID::CID_BUDDY_LIST_PC_LOGIN_STATUS_NOTIFY),
            527 => ::std::option::Option::Some(BuddyListCmdID::CID_BUDDY_LIST_REMOVE_SESSION_NOTIFY),
            528 => ::std::option::Option::Some(BuddyListCmdID::CID_BUDDY_LIST_DEPARTMENT_REQUEST),
            529 => ::std::option::Option::Some(BuddyListCmdID::CID_BUDDY_LIST_DEPARTMENT_RESPONSE),
            530 => ::std::option::Option::Some(BuddyListCmdID::CID_BUDDY_LIST_AVATAR_CHANGED_NOTIFY),
            531 => ::std::option::Option::Some(BuddyListCmdID::CID_BUDDY_LIST_CHANGE_SIGN_INFO_REQUEST),
            532 => ::std::option::Option::Some(BuddyListCmdID::CID_BUDDY_LIST_CHANGE_SIGN_INFO_RESPONSE),
            533 => ::std::option::Option::Some(BuddyListCmdID::CID_BUDDY_LIST_SIGN_INFO_CHANGED_NOTIFY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [BuddyListCmdID] = &[
            BuddyListCmdID::CID_BUDDY_LIST_RECENT_CONTACT_SESSION_REQUEST,
            BuddyListCmdID::CID_BUDDY_LIST_RECENT_CONTACT_SESSION_RESPONSE,
            BuddyListCmdID::CID_BUDDY_LIST_STATUS_NOTIFY,
            BuddyListCmdID::CID_BUDDY_LIST_USER_INFO_REQUEST,
            BuddyListCmdID::CID_BUDDY_LIST_USER_INFO_RESPONSE,
            BuddyListCmdID::CID_BUDDY_LIST_REMOVE_SESSION_REQ,
            BuddyListCmdID::CID_BUDDY_LIST_REMOVE_SESSION_RES,
            BuddyListCmdID::CID_BUDDY_LIST_ALL_USER_REQUEST,
            BuddyListCmdID::CID_BUDDY_LIST_ALL_USER_RESPONSE,
            BuddyListCmdID::CID_BUDDY_LIST_USERS_STATUS_REQUEST,
            BuddyListCmdID::CID_BUDDY_LIST_USERS_STATUS_RESPONSE,
            BuddyListCmdID::CID_BUDDY_LIST_CHANGE_AVATAR_REQUEST,
            BuddyListCmdID::CID_BUDDY_LIST_CHANGE_AVATAR_RESPONSE,
            BuddyListCmdID::CID_BUDDY_LIST_PC_LOGIN_STATUS_NOTIFY,
            BuddyListCmdID::CID_BUDDY_LIST_REMOVE_SESSION_NOTIFY,
            BuddyListCmdID::CID_BUDDY_LIST_DEPARTMENT_REQUEST,
            BuddyListCmdID::CID_BUDDY_LIST_DEPARTMENT_RESPONSE,
            BuddyListCmdID::CID_BUDDY_LIST_AVATAR_CHANGED_NOTIFY,
            BuddyListCmdID::CID_BUDDY_LIST_CHANGE_SIGN_INFO_REQUEST,
            BuddyListCmdID::CID_BUDDY_LIST_CHANGE_SIGN_INFO_RESPONSE,
            BuddyListCmdID::CID_BUDDY_LIST_SIGN_INFO_CHANGED_NOTIFY,
        ];
        values
    }
}

impl ::std::marker::Copy for BuddyListCmdID {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for BuddyListCmdID {
    fn default() -> Self {
        BuddyListCmdID::CID_BUDDY_LIST_RECENT_CONTACT_SESSION_REQUEST
    }
}

impl ::protobuf::reflect::ProtobufValue for BuddyListCmdID {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MessageCmdID {
    CID_MSG_DATA = 769,
    CID_MSG_DATA_ACK = 770,
    CID_MSG_READ_ACK = 771,
    CID_MSG_READ_NOTIFY = 772,
    CID_MSG_TIME_REQUEST = 773,
    CID_MSG_TIME_RESPONSE = 774,
    CID_MSG_UNREAD_CNT_REQUEST = 775,
    CID_MSG_UNREAD_CNT_RESPONSE = 776,
    CID_MSG_LIST_REQUEST = 777,
    CID_MSG_LIST_RESPONSE = 778,
    CID_MSG_GET_LATEST_MSG_ID_REQ = 779,
    CID_MSG_GET_LATEST_MSG_ID_RSP = 780,
    CID_MSG_GET_BY_MSG_ID_REQ = 781,
    CID_MSG_GET_BY_MSG_ID_RES = 782,
}

impl ::protobuf::ProtobufEnum for MessageCmdID {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MessageCmdID> {
        match value {
            769 => ::std::option::Option::Some(MessageCmdID::CID_MSG_DATA),
            770 => ::std::option::Option::Some(MessageCmdID::CID_MSG_DATA_ACK),
            771 => ::std::option::Option::Some(MessageCmdID::CID_MSG_READ_ACK),
            772 => ::std::option::Option::Some(MessageCmdID::CID_MSG_READ_NOTIFY),
            773 => ::std::option::Option::Some(MessageCmdID::CID_MSG_TIME_REQUEST),
            774 => ::std::option::Option::Some(MessageCmdID::CID_MSG_TIME_RESPONSE),
            775 => ::std::option::Option::Some(MessageCmdID::CID_MSG_UNREAD_CNT_REQUEST),
            776 => ::std::option::Option::Some(MessageCmdID::CID_MSG_UNREAD_CNT_RESPONSE),
            777 => ::std::option::Option::Some(MessageCmdID::CID_MSG_LIST_REQUEST),
            778 => ::std::option::Option::Some(MessageCmdID::CID_MSG_LIST_RESPONSE),
            779 => ::std::option::Option::Some(MessageCmdID::CID_MSG_GET_LATEST_MSG_ID_REQ),
            780 => ::std::option::Option::Some(MessageCmdID::CID_MSG_GET_LATEST_MSG_ID_RSP),
            781 => ::std::option::Option::Some(MessageCmdID::CID_MSG_GET_BY_MSG_ID_REQ),
            782 => ::std::option::Option::Some(MessageCmdID::CID_MSG_GET_BY_MSG_ID_RES),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MessageCmdID] = &[
            MessageCmdID::CID_MSG_DATA,
            MessageCmdID::CID_MSG_DATA_ACK,
            MessageCmdID::CID_MSG_READ_ACK,
            MessageCmdID::CID_MSG_READ_NOTIFY,
            MessageCmdID::CID_MSG_TIME_REQUEST,
            MessageCmdID::CID_MSG_TIME_RESPONSE,
            MessageCmdID::CID_MSG_UNREAD_CNT_REQUEST,
            MessageCmdID::CID_MSG_UNREAD_CNT_RESPONSE,
            MessageCmdID::CID_MSG_LIST_REQUEST,
            MessageCmdID::CID_MSG_LIST_RESPONSE,
            MessageCmdID::CID_MSG_GET_LATEST_MSG_ID_REQ,
            MessageCmdID::CID_MSG_GET_LATEST_MSG_ID_RSP,
            MessageCmdID::CID_MSG_GET_BY_MSG_ID_REQ,
            MessageCmdID::CID_MSG_GET_BY_MSG_ID_RES,
        ];
        values
    }
}

impl ::std::marker::Copy for MessageCmdID {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for MessageCmdID {
    fn default() -> Self {
        MessageCmdID::CID_MSG_DATA
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageCmdID {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum GroupCmdID {
    CID_GROUP_NORMAL_LIST_REQUEST = 1025,
    CID_GROUP_NORMAL_LIST_RESPONSE = 1026,
    CID_GROUP_INFO_REQUEST = 1027,
    CID_GROUP_INFO_RESPONSE = 1028,
    CID_GROUP_CREATE_REQUEST = 1029,
    CID_GROUP_CREATE_RESPONSE = 1030,
    CID_GROUP_CHANGE_MEMBER_REQUEST = 1031,
    CID_GROUP_CHANGE_MEMBER_RESPONSE = 1032,
    CID_GROUP_SHIELD_GROUP_REQUEST = 1033,
    CID_GROUP_SHIELD_GROUP_RESPONSE = 1034,
    CID_GROUP_CHANGE_MEMBER_NOTIFY = 1035,
}

impl ::protobuf::ProtobufEnum for GroupCmdID {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GroupCmdID> {
        match value {
            1025 => ::std::option::Option::Some(GroupCmdID::CID_GROUP_NORMAL_LIST_REQUEST),
            1026 => ::std::option::Option::Some(GroupCmdID::CID_GROUP_NORMAL_LIST_RESPONSE),
            1027 => ::std::option::Option::Some(GroupCmdID::CID_GROUP_INFO_REQUEST),
            1028 => ::std::option::Option::Some(GroupCmdID::CID_GROUP_INFO_RESPONSE),
            1029 => ::std::option::Option::Some(GroupCmdID::CID_GROUP_CREATE_REQUEST),
            1030 => ::std::option::Option::Some(GroupCmdID::CID_GROUP_CREATE_RESPONSE),
            1031 => ::std::option::Option::Some(GroupCmdID::CID_GROUP_CHANGE_MEMBER_REQUEST),
            1032 => ::std::option::Option::Some(GroupCmdID::CID_GROUP_CHANGE_MEMBER_RESPONSE),
            1033 => ::std::option::Option::Some(GroupCmdID::CID_GROUP_SHIELD_GROUP_REQUEST),
            1034 => ::std::option::Option::Some(GroupCmdID::CID_GROUP_SHIELD_GROUP_RESPONSE),
            1035 => ::std::option::Option::Some(GroupCmdID::CID_GROUP_CHANGE_MEMBER_NOTIFY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [GroupCmdID] = &[
            GroupCmdID::CID_GROUP_NORMAL_LIST_REQUEST,
            GroupCmdID::CID_GROUP_NORMAL_LIST_RESPONSE,
            GroupCmdID::CID_GROUP_INFO_REQUEST,
            GroupCmdID::CID_GROUP_INFO_RESPONSE,
            GroupCmdID::CID_GROUP_CREATE_REQUEST,
            GroupCmdID::CID_GROUP_CREATE_RESPONSE,
            GroupCmdID::CID_GROUP_CHANGE_MEMBER_REQUEST,
            GroupCmdID::CID_GROUP_CHANGE_MEMBER_RESPONSE,
            GroupCmdID::CID_GROUP_SHIELD_GROUP_REQUEST,
            GroupCmdID::CID_GROUP_SHIELD_GROUP_RESPONSE,
            GroupCmdID::CID_GROUP_CHANGE_MEMBER_NOTIFY,
        ];
        values
    }
}

impl ::std::marker::Copy for GroupCmdID {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for GroupCmdID {
    fn default() -> Self {
        GroupCmdID::CID_GROUP_NORMAL_LIST_REQUEST
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupCmdID {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FileCmdID {
    CID_FILE_LOGIN_REQ = 1281,
    CID_FILE_LOGIN_RES = 1282,
    CID_FILE_STATE = 1283,
    CID_FILE_PULL_DATA_REQ = 1284,
    CID_FILE_PULL_DATA_RSP = 1285,
    CID_FILE_REQUEST = 1286,
    CID_FILE_RESPONSE = 1287,
    CID_FILE_NOTIFY = 1288,
    CID_FILE_HAS_OFFLINE_REQ = 1289,
    CID_FILE_HAS_OFFLINE_RES = 1290,
    CID_FILE_ADD_OFFLINE_REQ = 1291,
    CID_FILE_DEL_OFFLINE_REQ = 1292,
}

impl ::protobuf::ProtobufEnum for FileCmdID {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FileCmdID> {
        match value {
            1281 => ::std::option::Option::Some(FileCmdID::CID_FILE_LOGIN_REQ),
            1282 => ::std::option::Option::Some(FileCmdID::CID_FILE_LOGIN_RES),
            1283 => ::std::option::Option::Some(FileCmdID::CID_FILE_STATE),
            1284 => ::std::option::Option::Some(FileCmdID::CID_FILE_PULL_DATA_REQ),
            1285 => ::std::option::Option::Some(FileCmdID::CID_FILE_PULL_DATA_RSP),
            1286 => ::std::option::Option::Some(FileCmdID::CID_FILE_REQUEST),
            1287 => ::std::option::Option::Some(FileCmdID::CID_FILE_RESPONSE),
            1288 => ::std::option::Option::Some(FileCmdID::CID_FILE_NOTIFY),
            1289 => ::std::option::Option::Some(FileCmdID::CID_FILE_HAS_OFFLINE_REQ),
            1290 => ::std::option::Option::Some(FileCmdID::CID_FILE_HAS_OFFLINE_RES),
            1291 => ::std::option::Option::Some(FileCmdID::CID_FILE_ADD_OFFLINE_REQ),
            1292 => ::std::option::Option::Some(FileCmdID::CID_FILE_DEL_OFFLINE_REQ),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FileCmdID] = &[
            FileCmdID::CID_FILE_LOGIN_REQ,
            FileCmdID::CID_FILE_LOGIN_RES,
            FileCmdID::CID_FILE_STATE,
            FileCmdID::CID_FILE_PULL_DATA_REQ,
            FileCmdID::CID_FILE_PULL_DATA_RSP,
            FileCmdID::CID_FILE_REQUEST,
            FileCmdID::CID_FILE_RESPONSE,
            FileCmdID::CID_FILE_NOTIFY,
            FileCmdID::CID_FILE_HAS_OFFLINE_REQ,
            FileCmdID::CID_FILE_HAS_OFFLINE_RES,
            FileCmdID::CID_FILE_ADD_OFFLINE_REQ,
            FileCmdID::CID_FILE_DEL_OFFLINE_REQ,
        ];
        values
    }
}

impl ::std::marker::Copy for FileCmdID {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for FileCmdID {
    fn default() -> Self {
        FileCmdID::CID_FILE_LOGIN_REQ
    }
}

impl ::protobuf::reflect::ProtobufValue for FileCmdID {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SwitchServiceCmdID {
    CID_SWITCH_P2P_CMD = 1537,
}

impl ::protobuf::ProtobufEnum for SwitchServiceCmdID {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SwitchServiceCmdID> {
        match value {
            1537 => ::std::option::Option::Some(SwitchServiceCmdID::CID_SWITCH_P2P_CMD),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SwitchServiceCmdID] = &[
            SwitchServiceCmdID::CID_SWITCH_P2P_CMD,
        ];
        values
    }
}

impl ::std::marker::Copy for SwitchServiceCmdID {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for SwitchServiceCmdID {
    fn default() -> Self {
        SwitchServiceCmdID::CID_SWITCH_P2P_CMD
    }
}

impl ::protobuf::reflect::ProtobufValue for SwitchServiceCmdID {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OtherCmdID {
    CID_OTHER_HEARTBEAT = 1793,
    CID_OTHER_STOP_RECV_PACKET = 1794,
    CID_OTHER_VALIDATE_REQ = 1795,
    CID_OTHER_VALIDATE_RSP = 1796,
    CID_OTHER_GET_DEVICE_TOKEN_REQ = 1797,
    CID_OTHER_GET_DEVICE_TOKEN_RSP = 1798,
    CID_OTHER_ROLE_SET = 1799,
    CID_OTHER_ONLINE_USER_INFO = 1800,
    CID_OTHER_MSG_SERV_INFO = 1801,
    CID_OTHER_USER_STATUS_UPDATE = 1802,
    CID_OTHER_USER_CNT_UPDATE = 1803,
    CID_OTHER_SERVER_KICK_USER = 1805,
    CID_OTHER_LOGIN_STATUS_NOTIFY = 1806,
    CID_OTHER_PUSH_TO_USER_REQ = 1807,
    CID_OTHER_PUSH_TO_USER_RSP = 1808,
    CID_OTHER_GET_SHIELD_REQ = 1809,
    CID_OTHER_GET_SHIELD_RSP = 1810,
    CID_OTHER_FILE_TRANSFER_REQ = 1841,
    CID_OTHER_FILE_TRANSFER_RSP = 1842,
    CID_OTHER_FILE_SERVER_IP_REQ = 1843,
    CID_OTHER_FILE_SERVER_IP_RSP = 1844,
}

impl ::protobuf::ProtobufEnum for OtherCmdID {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OtherCmdID> {
        match value {
            1793 => ::std::option::Option::Some(OtherCmdID::CID_OTHER_HEARTBEAT),
            1794 => ::std::option::Option::Some(OtherCmdID::CID_OTHER_STOP_RECV_PACKET),
            1795 => ::std::option::Option::Some(OtherCmdID::CID_OTHER_VALIDATE_REQ),
            1796 => ::std::option::Option::Some(OtherCmdID::CID_OTHER_VALIDATE_RSP),
            1797 => ::std::option::Option::Some(OtherCmdID::CID_OTHER_GET_DEVICE_TOKEN_REQ),
            1798 => ::std::option::Option::Some(OtherCmdID::CID_OTHER_GET_DEVICE_TOKEN_RSP),
            1799 => ::std::option::Option::Some(OtherCmdID::CID_OTHER_ROLE_SET),
            1800 => ::std::option::Option::Some(OtherCmdID::CID_OTHER_ONLINE_USER_INFO),
            1801 => ::std::option::Option::Some(OtherCmdID::CID_OTHER_MSG_SERV_INFO),
            1802 => ::std::option::Option::Some(OtherCmdID::CID_OTHER_USER_STATUS_UPDATE),
            1803 => ::std::option::Option::Some(OtherCmdID::CID_OTHER_USER_CNT_UPDATE),
            1805 => ::std::option::Option::Some(OtherCmdID::CID_OTHER_SERVER_KICK_USER),
            1806 => ::std::option::Option::Some(OtherCmdID::CID_OTHER_LOGIN_STATUS_NOTIFY),
            1807 => ::std::option::Option::Some(OtherCmdID::CID_OTHER_PUSH_TO_USER_REQ),
            1808 => ::std::option::Option::Some(OtherCmdID::CID_OTHER_PUSH_TO_USER_RSP),
            1809 => ::std::option::Option::Some(OtherCmdID::CID_OTHER_GET_SHIELD_REQ),
            1810 => ::std::option::Option::Some(OtherCmdID::CID_OTHER_GET_SHIELD_RSP),
            1841 => ::std::option::Option::Some(OtherCmdID::CID_OTHER_FILE_TRANSFER_REQ),
            1842 => ::std::option::Option::Some(OtherCmdID::CID_OTHER_FILE_TRANSFER_RSP),
            1843 => ::std::option::Option::Some(OtherCmdID::CID_OTHER_FILE_SERVER_IP_REQ),
            1844 => ::std::option::Option::Some(OtherCmdID::CID_OTHER_FILE_SERVER_IP_RSP),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OtherCmdID] = &[
            OtherCmdID::CID_OTHER_HEARTBEAT,
            OtherCmdID::CID_OTHER_STOP_RECV_PACKET,
            OtherCmdID::CID_OTHER_VALIDATE_REQ,
            OtherCmdID::CID_OTHER_VALIDATE_RSP,
            OtherCmdID::CID_OTHER_GET_DEVICE_TOKEN_REQ,
            OtherCmdID::CID_OTHER_GET_DEVICE_TOKEN_RSP,
            OtherCmdID::CID_OTHER_ROLE_SET,
            OtherCmdID::CID_OTHER_ONLINE_USER_INFO,
            OtherCmdID::CID_OTHER_MSG_SERV_INFO,
            OtherCmdID::CID_OTHER_USER_STATUS_UPDATE,
            OtherCmdID::CID_OTHER_USER_CNT_UPDATE,
            OtherCmdID::CID_OTHER_SERVER_KICK_USER,
            OtherCmdID::CID_OTHER_LOGIN_STATUS_NOTIFY,
            OtherCmdID::CID_OTHER_PUSH_TO_USER_REQ,
            OtherCmdID::CID_OTHER_PUSH_TO_USER_RSP,
            OtherCmdID::CID_OTHER_GET_SHIELD_REQ,
            OtherCmdID::CID_OTHER_GET_SHIELD_RSP,
            OtherCmdID::CID_OTHER_FILE_TRANSFER_REQ,
            OtherCmdID::CID_OTHER_FILE_TRANSFER_RSP,
            OtherCmdID::CID_OTHER_FILE_SERVER_IP_REQ,
            OtherCmdID::CID_OTHER_FILE_SERVER_IP_RSP,
        ];
        values
    }
}

impl ::std::marker::Copy for OtherCmdID {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for OtherCmdID {
    fn default() -> Self {
        OtherCmdID::CID_OTHER_HEARTBEAT
    }
}

impl ::protobuf::reflect::ProtobufValue for OtherCmdID {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ResultType {
    REFUSE_REASON_NONE = 0,
    REFUSE_REASON_NO_MSG_SERVER = 1,
    REFUSE_REASON_MSG_SERVER_FULL = 2,
    REFUSE_REASON_NO_DB_SERVER = 3,
    REFUSE_REASON_NO_LOGIN_SERVER = 4,
    REFUSE_REASON_NO_ROUTE_SERVER = 5,
    REFUSE_REASON_DB_VALIDATE_FAILED = 6,
    REFUSE_REASON_VERSION_TOO_OLD = 7,
}

impl ::protobuf::ProtobufEnum for ResultType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ResultType> {
        match value {
            0 => ::std::option::Option::Some(ResultType::REFUSE_REASON_NONE),
            1 => ::std::option::Option::Some(ResultType::REFUSE_REASON_NO_MSG_SERVER),
            2 => ::std::option::Option::Some(ResultType::REFUSE_REASON_MSG_SERVER_FULL),
            3 => ::std::option::Option::Some(ResultType::REFUSE_REASON_NO_DB_SERVER),
            4 => ::std::option::Option::Some(ResultType::REFUSE_REASON_NO_LOGIN_SERVER),
            5 => ::std::option::Option::Some(ResultType::REFUSE_REASON_NO_ROUTE_SERVER),
            6 => ::std::option::Option::Some(ResultType::REFUSE_REASON_DB_VALIDATE_FAILED),
            7 => ::std::option::Option::Some(ResultType::REFUSE_REASON_VERSION_TOO_OLD),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ResultType] = &[
            ResultType::REFUSE_REASON_NONE,
            ResultType::REFUSE_REASON_NO_MSG_SERVER,
            ResultType::REFUSE_REASON_MSG_SERVER_FULL,
            ResultType::REFUSE_REASON_NO_DB_SERVER,
            ResultType::REFUSE_REASON_NO_LOGIN_SERVER,
            ResultType::REFUSE_REASON_NO_ROUTE_SERVER,
            ResultType::REFUSE_REASON_DB_VALIDATE_FAILED,
            ResultType::REFUSE_REASON_VERSION_TOO_OLD,
        ];
        values
    }
}

impl ::std::marker::Copy for ResultType {
}

impl ::std::default::Default for ResultType {
    fn default() -> Self {
        ResultType::REFUSE_REASON_NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for ResultType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum KickReasonType {
    KICK_REASON_DUPLICATE_USER = 1,
    KICK_REASON_MOBILE_KICK = 2,
}

impl ::protobuf::ProtobufEnum for KickReasonType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<KickReasonType> {
        match value {
            1 => ::std::option::Option::Some(KickReasonType::KICK_REASON_DUPLICATE_USER),
            2 => ::std::option::Option::Some(KickReasonType::KICK_REASON_MOBILE_KICK),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [KickReasonType] = &[
            KickReasonType::KICK_REASON_DUPLICATE_USER,
            KickReasonType::KICK_REASON_MOBILE_KICK,
        ];
        values
    }
}

impl ::std::marker::Copy for KickReasonType {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for KickReasonType {
    fn default() -> Self {
        KickReasonType::KICK_REASON_DUPLICATE_USER
    }
}

impl ::protobuf::reflect::ProtobufValue for KickReasonType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OnlineListType {
    ONLINE_LIST_TYPE_FRIEND_LIST = 1,
}

impl ::protobuf::ProtobufEnum for OnlineListType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OnlineListType> {
        match value {
            1 => ::std::option::Option::Some(OnlineListType::ONLINE_LIST_TYPE_FRIEND_LIST),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OnlineListType] = &[
            OnlineListType::ONLINE_LIST_TYPE_FRIEND_LIST,
        ];
        values
    }
}

impl ::std::marker::Copy for OnlineListType {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for OnlineListType {
    fn default() -> Self {
        OnlineListType::ONLINE_LIST_TYPE_FRIEND_LIST
    }
}

impl ::protobuf::reflect::ProtobufValue for OnlineListType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum UserStatType {
    USER_STATUS_ONLINE = 1,
    USER_STATUS_OFFLINE = 2,
    USER_STATUS_LEAVE = 3,
}

impl ::protobuf::ProtobufEnum for UserStatType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<UserStatType> {
        match value {
            1 => ::std::option::Option::Some(UserStatType::USER_STATUS_ONLINE),
            2 => ::std::option::Option::Some(UserStatType::USER_STATUS_OFFLINE),
            3 => ::std::option::Option::Some(UserStatType::USER_STATUS_LEAVE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [UserStatType] = &[
            UserStatType::USER_STATUS_ONLINE,
            UserStatType::USER_STATUS_OFFLINE,
            UserStatType::USER_STATUS_LEAVE,
        ];
        values
    }
}

impl ::std::marker::Copy for UserStatType {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for UserStatType {
    fn default() -> Self {
        UserStatType::USER_STATUS_ONLINE
    }
}

impl ::protobuf::reflect::ProtobufValue for UserStatType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SessionType {
    SESSION_TYPE_SINGLE = 1,
    SESSION_TYPE_GROUP = 2,
}

impl ::protobuf::ProtobufEnum for SessionType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SessionType> {
        match value {
            1 => ::std::option::Option::Some(SessionType::SESSION_TYPE_SINGLE),
            2 => ::std::option::Option::Some(SessionType::SESSION_TYPE_GROUP),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SessionType] = &[
            SessionType::SESSION_TYPE_SINGLE,
            SessionType::SESSION_TYPE_GROUP,
        ];
        values
    }
}

impl ::std::marker::Copy for SessionType {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for SessionType {
    fn default() -> Self {
        SessionType::SESSION_TYPE_SINGLE
    }
}

impl ::protobuf::reflect::ProtobufValue for SessionType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MsgType {
    MSG_TYPE_SINGLE_TEXT = 1,
    MSG_TYPE_SINGLE_AUDIO = 2,
    MSG_TYPE_GROUP_TEXT = 17,
    MSG_TYPE_GROUP_AUDIO = 18,
}

impl ::protobuf::ProtobufEnum for MsgType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MsgType> {
        match value {
            1 => ::std::option::Option::Some(MsgType::MSG_TYPE_SINGLE_TEXT),
            2 => ::std::option::Option::Some(MsgType::MSG_TYPE_SINGLE_AUDIO),
            17 => ::std::option::Option::Some(MsgType::MSG_TYPE_GROUP_TEXT),
            18 => ::std::option::Option::Some(MsgType::MSG_TYPE_GROUP_AUDIO),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MsgType] = &[
            MsgType::MSG_TYPE_SINGLE_TEXT,
            MsgType::MSG_TYPE_SINGLE_AUDIO,
            MsgType::MSG_TYPE_GROUP_TEXT,
            MsgType::MSG_TYPE_GROUP_AUDIO,
        ];
        values
    }
}

impl ::std::marker::Copy for MsgType {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for MsgType {
    fn default() -> Self {
        MsgType::MSG_TYPE_SINGLE_TEXT
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ClientType {
    CLIENT_TYPE_WINDOWS = 1,
    CLIENT_TYPE_MAC = 2,
    CLIENT_TYPE_IOS = 17,
    CLIENT_TYPE_ANDROID = 18,
}

impl ::protobuf::ProtobufEnum for ClientType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ClientType> {
        match value {
            1 => ::std::option::Option::Some(ClientType::CLIENT_TYPE_WINDOWS),
            2 => ::std::option::Option::Some(ClientType::CLIENT_TYPE_MAC),
            17 => ::std::option::Option::Some(ClientType::CLIENT_TYPE_IOS),
            18 => ::std::option::Option::Some(ClientType::CLIENT_TYPE_ANDROID),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ClientType] = &[
            ClientType::CLIENT_TYPE_WINDOWS,
            ClientType::CLIENT_TYPE_MAC,
            ClientType::CLIENT_TYPE_IOS,
            ClientType::CLIENT_TYPE_ANDROID,
        ];
        values
    }
}

impl ::std::marker::Copy for ClientType {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ClientType {
    fn default() -> Self {
        ClientType::CLIENT_TYPE_WINDOWS
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum GroupType {
    GROUP_TYPE_NORMAL = 1,
    GROUP_TYPE_TMP = 2,
}

impl ::protobuf::ProtobufEnum for GroupType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GroupType> {
        match value {
            1 => ::std::option::Option::Some(GroupType::GROUP_TYPE_NORMAL),
            2 => ::std::option::Option::Some(GroupType::GROUP_TYPE_TMP),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [GroupType] = &[
            GroupType::GROUP_TYPE_NORMAL,
            GroupType::GROUP_TYPE_TMP,
        ];
        values
    }
}

impl ::std::marker::Copy for GroupType {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for GroupType {
    fn default() -> Self {
        GroupType::GROUP_TYPE_NORMAL
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum GroupModifyType {
    GROUP_MODIFY_TYPE_ADD = 1,
    GROUP_MODIFY_TYPE_DEL = 2,
}

impl ::protobuf::ProtobufEnum for GroupModifyType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GroupModifyType> {
        match value {
            1 => ::std::option::Option::Some(GroupModifyType::GROUP_MODIFY_TYPE_ADD),
            2 => ::std::option::Option::Some(GroupModifyType::GROUP_MODIFY_TYPE_DEL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [GroupModifyType] = &[
            GroupModifyType::GROUP_MODIFY_TYPE_ADD,
            GroupModifyType::GROUP_MODIFY_TYPE_DEL,
        ];
        values
    }
}

impl ::std::marker::Copy for GroupModifyType {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for GroupModifyType {
    fn default() -> Self {
        GroupModifyType::GROUP_MODIFY_TYPE_ADD
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupModifyType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TransferFileType {
    FILE_TYPE_ONLINE = 1,
    FILE_TYPE_OFFLINE = 2,
}

impl ::protobuf::ProtobufEnum for TransferFileType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TransferFileType> {
        match value {
            1 => ::std::option::Option::Some(TransferFileType::FILE_TYPE_ONLINE),
            2 => ::std::option::Option::Some(TransferFileType::FILE_TYPE_OFFLINE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TransferFileType] = &[
            TransferFileType::FILE_TYPE_ONLINE,
            TransferFileType::FILE_TYPE_OFFLINE,
        ];
        values
    }
}

impl ::std::marker::Copy for TransferFileType {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for TransferFileType {
    fn default() -> Self {
        TransferFileType::FILE_TYPE_ONLINE
    }
}

impl ::protobuf::reflect::ProtobufValue for TransferFileType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ClientFileState {
    CLIENT_FILE_PEER_READY = 0,
    CLIENT_FILE_CANCEL = 1,
    CLIENT_FILE_REFUSE = 2,
    CLIENT_FILE_DONE = 3,
}

impl ::protobuf::ProtobufEnum for ClientFileState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ClientFileState> {
        match value {
            0 => ::std::option::Option::Some(ClientFileState::CLIENT_FILE_PEER_READY),
            1 => ::std::option::Option::Some(ClientFileState::CLIENT_FILE_CANCEL),
            2 => ::std::option::Option::Some(ClientFileState::CLIENT_FILE_REFUSE),
            3 => ::std::option::Option::Some(ClientFileState::CLIENT_FILE_DONE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ClientFileState] = &[
            ClientFileState::CLIENT_FILE_PEER_READY,
            ClientFileState::CLIENT_FILE_CANCEL,
            ClientFileState::CLIENT_FILE_REFUSE,
            ClientFileState::CLIENT_FILE_DONE,
        ];
        values
    }
}

impl ::std::marker::Copy for ClientFileState {
}

impl ::std::default::Default for ClientFileState {
    fn default() -> Self {
        ClientFileState::CLIENT_FILE_PEER_READY
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientFileState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ClientFileRole {
    CLIENT_REALTIME_SENDER = 1,
    CLIENT_REALTIME_RECVER = 2,
    CLIENT_OFFLINE_UPLOAD = 3,
    CLIENT_OFFLINE_DOWNLOAD = 4,
}

impl ::protobuf::ProtobufEnum for ClientFileRole {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ClientFileRole> {
        match value {
            1 => ::std::option::Option::Some(ClientFileRole::CLIENT_REALTIME_SENDER),
            2 => ::std::option::Option::Some(ClientFileRole::CLIENT_REALTIME_RECVER),
            3 => ::std::option::Option::Some(ClientFileRole::CLIENT_OFFLINE_UPLOAD),
            4 => ::std::option::Option::Some(ClientFileRole::CLIENT_OFFLINE_DOWNLOAD),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ClientFileRole] = &[
            ClientFileRole::CLIENT_REALTIME_SENDER,
            ClientFileRole::CLIENT_REALTIME_RECVER,
            ClientFileRole::CLIENT_OFFLINE_UPLOAD,
            ClientFileRole::CLIENT_OFFLINE_DOWNLOAD,
        ];
        values
    }
}

impl ::std::marker::Copy for ClientFileRole {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ClientFileRole {
    fn default() -> Self {
        ClientFileRole::CLIENT_REALTIME_SENDER
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientFileRole {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FileServerError {
    FILE_SERVER_ERRNO_OK = 0,
    FILE_SERVER_ERRNO_CREATE_TASK_ID_ERROR = 1,
    FILE_SERVER_ERRNO_CREATE_TASK_ERROR = 2,
    FILE_SERVER_ERRNO_LOGIN_INVALID_TOKEN = 3,
    FILE_SERVER_ERRNO_INVALID_USER_FOR_TASK = 4,
    FILE_SERVER_ERRNO_PULL_DATA_WITH_INVALID_TASK_ID = 5,
    FILE_SERVER_ERRNO_PULL_DATA_ILLIEAGE_USER = 6,
    FILE_SERVER_ERRNO_PULL_DATA_MKDIR_ERROR = 7,
    FILE_SERVER_ERRNO_PULL_DATA_OPEN_FILE_ERROR = 8,
    FILE_SERVER_ERRNO_PULL_DATA_READ_FILE_HEADER_ERROR = 9,
    FILE_SERVER_ERRNO_PULL_DATA_ALLOC_MEM_ERROR = 10,
    FILE_SERVER_ERRNO_PULL_DATA_SEEK_OFFSET_ERROR = 11,
    FILE_SERVER_ERRNO_PULL_DATA_FINISHED = 12,
}

impl ::protobuf::ProtobufEnum for FileServerError {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FileServerError> {
        match value {
            0 => ::std::option::Option::Some(FileServerError::FILE_SERVER_ERRNO_OK),
            1 => ::std::option::Option::Some(FileServerError::FILE_SERVER_ERRNO_CREATE_TASK_ID_ERROR),
            2 => ::std::option::Option::Some(FileServerError::FILE_SERVER_ERRNO_CREATE_TASK_ERROR),
            3 => ::std::option::Option::Some(FileServerError::FILE_SERVER_ERRNO_LOGIN_INVALID_TOKEN),
            4 => ::std::option::Option::Some(FileServerError::FILE_SERVER_ERRNO_INVALID_USER_FOR_TASK),
            5 => ::std::option::Option::Some(FileServerError::FILE_SERVER_ERRNO_PULL_DATA_WITH_INVALID_TASK_ID),
            6 => ::std::option::Option::Some(FileServerError::FILE_SERVER_ERRNO_PULL_DATA_ILLIEAGE_USER),
            7 => ::std::option::Option::Some(FileServerError::FILE_SERVER_ERRNO_PULL_DATA_MKDIR_ERROR),
            8 => ::std::option::Option::Some(FileServerError::FILE_SERVER_ERRNO_PULL_DATA_OPEN_FILE_ERROR),
            9 => ::std::option::Option::Some(FileServerError::FILE_SERVER_ERRNO_PULL_DATA_READ_FILE_HEADER_ERROR),
            10 => ::std::option::Option::Some(FileServerError::FILE_SERVER_ERRNO_PULL_DATA_ALLOC_MEM_ERROR),
            11 => ::std::option::Option::Some(FileServerError::FILE_SERVER_ERRNO_PULL_DATA_SEEK_OFFSET_ERROR),
            12 => ::std::option::Option::Some(FileServerError::FILE_SERVER_ERRNO_PULL_DATA_FINISHED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FileServerError] = &[
            FileServerError::FILE_SERVER_ERRNO_OK,
            FileServerError::FILE_SERVER_ERRNO_CREATE_TASK_ID_ERROR,
            FileServerError::FILE_SERVER_ERRNO_CREATE_TASK_ERROR,
            FileServerError::FILE_SERVER_ERRNO_LOGIN_INVALID_TOKEN,
            FileServerError::FILE_SERVER_ERRNO_INVALID_USER_FOR_TASK,
            FileServerError::FILE_SERVER_ERRNO_PULL_DATA_WITH_INVALID_TASK_ID,
            FileServerError::FILE_SERVER_ERRNO_PULL_DATA_ILLIEAGE_USER,
            FileServerError::FILE_SERVER_ERRNO_PULL_DATA_MKDIR_ERROR,
            FileServerError::FILE_SERVER_ERRNO_PULL_DATA_OPEN_FILE_ERROR,
            FileServerError::FILE_SERVER_ERRNO_PULL_DATA_READ_FILE_HEADER_ERROR,
            FileServerError::FILE_SERVER_ERRNO_PULL_DATA_ALLOC_MEM_ERROR,
            FileServerError::FILE_SERVER_ERRNO_PULL_DATA_SEEK_OFFSET_ERROR,
            FileServerError::FILE_SERVER_ERRNO_PULL_DATA_FINISHED,
        ];
        values
    }
}

impl ::std::marker::Copy for FileServerError {
}

impl ::std::default::Default for FileServerError {
    fn default() -> Self {
        FileServerError::FILE_SERVER_ERRNO_OK
    }
}

impl ::protobuf::reflect::ProtobufValue for FileServerError {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SessionStatusType {
    SESSION_STATUS_OK = 0,
    SESSION_STATUS_DELETE = 1,
}

impl ::protobuf::ProtobufEnum for SessionStatusType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SessionStatusType> {
        match value {
            0 => ::std::option::Option::Some(SessionStatusType::SESSION_STATUS_OK),
            1 => ::std::option::Option::Some(SessionStatusType::SESSION_STATUS_DELETE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SessionStatusType] = &[
            SessionStatusType::SESSION_STATUS_OK,
            SessionStatusType::SESSION_STATUS_DELETE,
        ];
        values
    }
}

impl ::std::marker::Copy for SessionStatusType {
}

impl ::std::default::Default for SessionStatusType {
    fn default() -> Self {
        SessionStatusType::SESSION_STATUS_OK
    }
}

impl ::protobuf::reflect::ProtobufValue for SessionStatusType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DepartmentStatusType {
    DEPT_STATUS_OK = 0,
    DEPT_STATUS_DELETE = 1,
}

impl ::protobuf::ProtobufEnum for DepartmentStatusType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DepartmentStatusType> {
        match value {
            0 => ::std::option::Option::Some(DepartmentStatusType::DEPT_STATUS_OK),
            1 => ::std::option::Option::Some(DepartmentStatusType::DEPT_STATUS_DELETE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DepartmentStatusType] = &[
            DepartmentStatusType::DEPT_STATUS_OK,
            DepartmentStatusType::DEPT_STATUS_DELETE,
        ];
        values
    }
}

impl ::std::marker::Copy for DepartmentStatusType {
}

impl ::std::default::Default for DepartmentStatusType {
    fn default() -> Self {
        DepartmentStatusType::DEPT_STATUS_OK
    }
}

impl ::protobuf::reflect::ProtobufValue for DepartmentStatusType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}
