// This file is generated by rust-protobuf 2.7.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `IM.Buddy.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_7_0;

#[derive(PartialEq,Clone,Default,Debug)]
pub struct IMRecentContactSessionReq {
    // message fields
    user_id: ::std::option::Option<u32>,
    latest_update_time: ::std::option::Option<u32>,
    attach_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IMRecentContactSessionReq {
    fn default() -> &'a IMRecentContactSessionReq {
        <IMRecentContactSessionReq as ::protobuf::Message>::default_instance()
    }
}

impl IMRecentContactSessionReq {
    pub fn new() -> IMRecentContactSessionReq {
        ::std::default::Default::default()
    }

    // required uint32 user_id = 1;


    pub fn get_user_id(&self) -> u32 {
        self.user_id.unwrap_or(0)
    }
    pub fn clear_user_id(&mut self) {
        self.user_id = ::std::option::Option::None;
    }

    pub fn has_user_id(&self) -> bool {
        self.user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: u32) {
        self.user_id = ::std::option::Option::Some(v);
    }

    // required uint32 latest_update_time = 2;


    pub fn get_latest_update_time(&self) -> u32 {
        self.latest_update_time.unwrap_or(0)
    }
    pub fn clear_latest_update_time(&mut self) {
        self.latest_update_time = ::std::option::Option::None;
    }

    pub fn has_latest_update_time(&self) -> bool {
        self.latest_update_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_latest_update_time(&mut self, v: u32) {
        self.latest_update_time = ::std::option::Option::Some(v);
    }

    // optional bytes attach_data = 20;


    pub fn get_attach_data(&self) -> &[u8] {
        match self.attach_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_attach_data(&mut self) {
        self.attach_data.clear();
    }

    pub fn has_attach_data(&self) -> bool {
        self.attach_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attach_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.attach_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attach_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.attach_data.is_none() {
            self.attach_data.set_default();
        }
        self.attach_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_attach_data(&mut self) -> ::std::vec::Vec<u8> {
        self.attach_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for IMRecentContactSessionReq {
    fn is_initialized(&self) -> bool {
        if self.user_id.is_none() {
            return false;
        }
        if self.latest_update_time.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.user_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.latest_update_time = ::std::option::Option::Some(tmp);
                },
                20 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.attach_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.user_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.latest_update_time {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.attach_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(20, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.user_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.latest_update_time {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.attach_data.as_ref() {
            os.write_bytes(20, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IMRecentContactSessionReq {
        IMRecentContactSessionReq::new()
    }

    fn default_instance() -> &'static IMRecentContactSessionReq {
        static mut instance: ::protobuf::lazy::Lazy<IMRecentContactSessionReq> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IMRecentContactSessionReq,
        };
        unsafe {
            instance.get(IMRecentContactSessionReq::new)
        }
    }
}

impl ::protobuf::Clear for IMRecentContactSessionReq {
    fn clear(&mut self) {
        self.user_id = ::std::option::Option::None;
        self.latest_update_time = ::std::option::Option::None;
        self.attach_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for IMRecentContactSessionReq {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct IMRecentContactSessionRsp {
    // message fields
    user_id: ::std::option::Option<u32>,
    contact_session_list: ::protobuf::RepeatedField<super::IM_BaseDefine::ContactSessionInfo>,
    attach_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IMRecentContactSessionRsp {
    fn default() -> &'a IMRecentContactSessionRsp {
        <IMRecentContactSessionRsp as ::protobuf::Message>::default_instance()
    }
}

impl IMRecentContactSessionRsp {
    pub fn new() -> IMRecentContactSessionRsp {
        ::std::default::Default::default()
    }

    // required uint32 user_id = 1;


    pub fn get_user_id(&self) -> u32 {
        self.user_id.unwrap_or(0)
    }
    pub fn clear_user_id(&mut self) {
        self.user_id = ::std::option::Option::None;
    }

    pub fn has_user_id(&self) -> bool {
        self.user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: u32) {
        self.user_id = ::std::option::Option::Some(v);
    }

    // repeated .IM.BaseDefine.ContactSessionInfo contact_session_list = 2;


    pub fn get_contact_session_list(&self) -> &[super::IM_BaseDefine::ContactSessionInfo] {
        &self.contact_session_list
    }
    pub fn clear_contact_session_list(&mut self) {
        self.contact_session_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_contact_session_list(&mut self, v: ::protobuf::RepeatedField<super::IM_BaseDefine::ContactSessionInfo>) {
        self.contact_session_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_contact_session_list(&mut self) -> &mut ::protobuf::RepeatedField<super::IM_BaseDefine::ContactSessionInfo> {
        &mut self.contact_session_list
    }

    // Take field
    pub fn take_contact_session_list(&mut self) -> ::protobuf::RepeatedField<super::IM_BaseDefine::ContactSessionInfo> {
        ::std::mem::replace(&mut self.contact_session_list, ::protobuf::RepeatedField::new())
    }

    // optional bytes attach_data = 20;


    pub fn get_attach_data(&self) -> &[u8] {
        match self.attach_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_attach_data(&mut self) {
        self.attach_data.clear();
    }

    pub fn has_attach_data(&self) -> bool {
        self.attach_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attach_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.attach_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attach_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.attach_data.is_none() {
            self.attach_data.set_default();
        }
        self.attach_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_attach_data(&mut self) -> ::std::vec::Vec<u8> {
        self.attach_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for IMRecentContactSessionRsp {
    fn is_initialized(&self) -> bool {
        if self.user_id.is_none() {
            return false;
        }
        for v in &self.contact_session_list {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.user_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.contact_session_list)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.attach_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.user_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.contact_session_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.attach_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(20, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.user_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.contact_session_list {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.attach_data.as_ref() {
            os.write_bytes(20, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IMRecentContactSessionRsp {
        IMRecentContactSessionRsp::new()
    }

    fn default_instance() -> &'static IMRecentContactSessionRsp {
        static mut instance: ::protobuf::lazy::Lazy<IMRecentContactSessionRsp> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IMRecentContactSessionRsp,
        };
        unsafe {
            instance.get(IMRecentContactSessionRsp::new)
        }
    }
}

impl ::protobuf::Clear for IMRecentContactSessionRsp {
    fn clear(&mut self) {
        self.user_id = ::std::option::Option::None;
        self.contact_session_list.clear();
        self.attach_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for IMRecentContactSessionRsp {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct IMUserStatNotify {
    // message fields
    user_stat: ::protobuf::SingularPtrField<super::IM_BaseDefine::UserStat>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IMUserStatNotify {
    fn default() -> &'a IMUserStatNotify {
        <IMUserStatNotify as ::protobuf::Message>::default_instance()
    }
}

impl IMUserStatNotify {
    pub fn new() -> IMUserStatNotify {
        ::std::default::Default::default()
    }

    // required .IM.BaseDefine.UserStat user_stat = 1;


    pub fn get_user_stat(&self) -> &super::IM_BaseDefine::UserStat {
        self.user_stat.as_ref().unwrap_or_else(|| super::IM_BaseDefine::UserStat::default_instance())
    }
    pub fn clear_user_stat(&mut self) {
        self.user_stat.clear();
    }

    pub fn has_user_stat(&self) -> bool {
        self.user_stat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_stat(&mut self, v: super::IM_BaseDefine::UserStat) {
        self.user_stat = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_stat(&mut self) -> &mut super::IM_BaseDefine::UserStat {
        if self.user_stat.is_none() {
            self.user_stat.set_default();
        }
        self.user_stat.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_stat(&mut self) -> super::IM_BaseDefine::UserStat {
        self.user_stat.take().unwrap_or_else(|| super::IM_BaseDefine::UserStat::new())
    }
}

impl ::protobuf::Message for IMUserStatNotify {
    fn is_initialized(&self) -> bool {
        if self.user_stat.is_none() {
            return false;
        }
        for v in &self.user_stat {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_stat)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_stat.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_stat.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IMUserStatNotify {
        IMUserStatNotify::new()
    }

    fn default_instance() -> &'static IMUserStatNotify {
        static mut instance: ::protobuf::lazy::Lazy<IMUserStatNotify> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IMUserStatNotify,
        };
        unsafe {
            instance.get(IMUserStatNotify::new)
        }
    }
}

impl ::protobuf::Clear for IMUserStatNotify {
    fn clear(&mut self) {
        self.user_stat.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for IMUserStatNotify {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct IMUsersInfoReq {
    // message fields
    user_id: ::std::option::Option<u32>,
    user_id_list: ::std::vec::Vec<u32>,
    attach_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IMUsersInfoReq {
    fn default() -> &'a IMUsersInfoReq {
        <IMUsersInfoReq as ::protobuf::Message>::default_instance()
    }
}

impl IMUsersInfoReq {
    pub fn new() -> IMUsersInfoReq {
        ::std::default::Default::default()
    }

    // required uint32 user_id = 1;


    pub fn get_user_id(&self) -> u32 {
        self.user_id.unwrap_or(0)
    }
    pub fn clear_user_id(&mut self) {
        self.user_id = ::std::option::Option::None;
    }

    pub fn has_user_id(&self) -> bool {
        self.user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: u32) {
        self.user_id = ::std::option::Option::Some(v);
    }

    // repeated uint32 user_id_list = 2;


    pub fn get_user_id_list(&self) -> &[u32] {
        &self.user_id_list
    }
    pub fn clear_user_id_list(&mut self) {
        self.user_id_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_id_list(&mut self, v: ::std::vec::Vec<u32>) {
        self.user_id_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_user_id_list(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.user_id_list
    }

    // Take field
    pub fn take_user_id_list(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.user_id_list, ::std::vec::Vec::new())
    }

    // optional bytes attach_data = 20;


    pub fn get_attach_data(&self) -> &[u8] {
        match self.attach_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_attach_data(&mut self) {
        self.attach_data.clear();
    }

    pub fn has_attach_data(&self) -> bool {
        self.attach_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attach_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.attach_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attach_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.attach_data.is_none() {
            self.attach_data.set_default();
        }
        self.attach_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_attach_data(&mut self) -> ::std::vec::Vec<u8> {
        self.attach_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for IMUsersInfoReq {
    fn is_initialized(&self) -> bool {
        if self.user_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.user_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.user_id_list)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.attach_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.user_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.user_id_list {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.attach_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(20, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.user_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.user_id_list {
            os.write_uint32(2, *v)?;
        };
        if let Some(ref v) = self.attach_data.as_ref() {
            os.write_bytes(20, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IMUsersInfoReq {
        IMUsersInfoReq::new()
    }

    fn default_instance() -> &'static IMUsersInfoReq {
        static mut instance: ::protobuf::lazy::Lazy<IMUsersInfoReq> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IMUsersInfoReq,
        };
        unsafe {
            instance.get(IMUsersInfoReq::new)
        }
    }
}

impl ::protobuf::Clear for IMUsersInfoReq {
    fn clear(&mut self) {
        self.user_id = ::std::option::Option::None;
        self.user_id_list.clear();
        self.attach_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for IMUsersInfoReq {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct IMUsersInfoRsp {
    // message fields
    user_id: ::std::option::Option<u32>,
    user_info_list: ::protobuf::RepeatedField<super::IM_BaseDefine::UserInfo>,
    attach_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IMUsersInfoRsp {
    fn default() -> &'a IMUsersInfoRsp {
        <IMUsersInfoRsp as ::protobuf::Message>::default_instance()
    }
}

impl IMUsersInfoRsp {
    pub fn new() -> IMUsersInfoRsp {
        ::std::default::Default::default()
    }

    // required uint32 user_id = 1;


    pub fn get_user_id(&self) -> u32 {
        self.user_id.unwrap_or(0)
    }
    pub fn clear_user_id(&mut self) {
        self.user_id = ::std::option::Option::None;
    }

    pub fn has_user_id(&self) -> bool {
        self.user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: u32) {
        self.user_id = ::std::option::Option::Some(v);
    }

    // repeated .IM.BaseDefine.UserInfo user_info_list = 2;


    pub fn get_user_info_list(&self) -> &[super::IM_BaseDefine::UserInfo] {
        &self.user_info_list
    }
    pub fn clear_user_info_list(&mut self) {
        self.user_info_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_info_list(&mut self, v: ::protobuf::RepeatedField<super::IM_BaseDefine::UserInfo>) {
        self.user_info_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_user_info_list(&mut self) -> &mut ::protobuf::RepeatedField<super::IM_BaseDefine::UserInfo> {
        &mut self.user_info_list
    }

    // Take field
    pub fn take_user_info_list(&mut self) -> ::protobuf::RepeatedField<super::IM_BaseDefine::UserInfo> {
        ::std::mem::replace(&mut self.user_info_list, ::protobuf::RepeatedField::new())
    }

    // optional bytes attach_data = 20;


    pub fn get_attach_data(&self) -> &[u8] {
        match self.attach_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_attach_data(&mut self) {
        self.attach_data.clear();
    }

    pub fn has_attach_data(&self) -> bool {
        self.attach_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attach_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.attach_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attach_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.attach_data.is_none() {
            self.attach_data.set_default();
        }
        self.attach_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_attach_data(&mut self) -> ::std::vec::Vec<u8> {
        self.attach_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for IMUsersInfoRsp {
    fn is_initialized(&self) -> bool {
        if self.user_id.is_none() {
            return false;
        }
        for v in &self.user_info_list {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.user_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.user_info_list)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.attach_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.user_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.user_info_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.attach_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(20, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.user_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.user_info_list {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.attach_data.as_ref() {
            os.write_bytes(20, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IMUsersInfoRsp {
        IMUsersInfoRsp::new()
    }

    fn default_instance() -> &'static IMUsersInfoRsp {
        static mut instance: ::protobuf::lazy::Lazy<IMUsersInfoRsp> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IMUsersInfoRsp,
        };
        unsafe {
            instance.get(IMUsersInfoRsp::new)
        }
    }
}

impl ::protobuf::Clear for IMUsersInfoRsp {
    fn clear(&mut self) {
        self.user_id = ::std::option::Option::None;
        self.user_info_list.clear();
        self.attach_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for IMUsersInfoRsp {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct IMRemoveSessionReq {
    // message fields
    user_id: ::std::option::Option<u32>,
    session_type: ::std::option::Option<super::IM_BaseDefine::SessionType>,
    session_id: ::std::option::Option<u32>,
    attach_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IMRemoveSessionReq {
    fn default() -> &'a IMRemoveSessionReq {
        <IMRemoveSessionReq as ::protobuf::Message>::default_instance()
    }
}

impl IMRemoveSessionReq {
    pub fn new() -> IMRemoveSessionReq {
        ::std::default::Default::default()
    }

    // required uint32 user_id = 1;


    pub fn get_user_id(&self) -> u32 {
        self.user_id.unwrap_or(0)
    }
    pub fn clear_user_id(&mut self) {
        self.user_id = ::std::option::Option::None;
    }

    pub fn has_user_id(&self) -> bool {
        self.user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: u32) {
        self.user_id = ::std::option::Option::Some(v);
    }

    // required .IM.BaseDefine.SessionType session_type = 2;


    pub fn get_session_type(&self) -> super::IM_BaseDefine::SessionType {
        self.session_type.unwrap_or(super::IM_BaseDefine::SessionType::SESSION_TYPE_SINGLE)
    }
    pub fn clear_session_type(&mut self) {
        self.session_type = ::std::option::Option::None;
    }

    pub fn has_session_type(&self) -> bool {
        self.session_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_type(&mut self, v: super::IM_BaseDefine::SessionType) {
        self.session_type = ::std::option::Option::Some(v);
    }

    // required uint32 session_id = 3;


    pub fn get_session_id(&self) -> u32 {
        self.session_id.unwrap_or(0)
    }
    pub fn clear_session_id(&mut self) {
        self.session_id = ::std::option::Option::None;
    }

    pub fn has_session_id(&self) -> bool {
        self.session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_id(&mut self, v: u32) {
        self.session_id = ::std::option::Option::Some(v);
    }

    // optional bytes attach_data = 20;


    pub fn get_attach_data(&self) -> &[u8] {
        match self.attach_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_attach_data(&mut self) {
        self.attach_data.clear();
    }

    pub fn has_attach_data(&self) -> bool {
        self.attach_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attach_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.attach_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attach_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.attach_data.is_none() {
            self.attach_data.set_default();
        }
        self.attach_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_attach_data(&mut self) -> ::std::vec::Vec<u8> {
        self.attach_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for IMRemoveSessionReq {
    fn is_initialized(&self) -> bool {
        if self.user_id.is_none() {
            return false;
        }
        if self.session_type.is_none() {
            return false;
        }
        if self.session_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.user_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.session_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.session_id = ::std::option::Option::Some(tmp);
                },
                20 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.attach_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.user_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.session_type {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.session_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.attach_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(20, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.user_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.session_type {
            os.write_enum(2, v.value())?;
        }
        if let Some(v) = self.session_id {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.attach_data.as_ref() {
            os.write_bytes(20, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IMRemoveSessionReq {
        IMRemoveSessionReq::new()
    }

    fn default_instance() -> &'static IMRemoveSessionReq {
        static mut instance: ::protobuf::lazy::Lazy<IMRemoveSessionReq> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IMRemoveSessionReq,
        };
        unsafe {
            instance.get(IMRemoveSessionReq::new)
        }
    }
}

impl ::protobuf::Clear for IMRemoveSessionReq {
    fn clear(&mut self) {
        self.user_id = ::std::option::Option::None;
        self.session_type = ::std::option::Option::None;
        self.session_id = ::std::option::Option::None;
        self.attach_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for IMRemoveSessionReq {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct IMRemoveSessionRsp {
    // message fields
    user_id: ::std::option::Option<u32>,
    result_code: ::std::option::Option<u32>,
    session_type: ::std::option::Option<super::IM_BaseDefine::SessionType>,
    session_id: ::std::option::Option<u32>,
    attach_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IMRemoveSessionRsp {
    fn default() -> &'a IMRemoveSessionRsp {
        <IMRemoveSessionRsp as ::protobuf::Message>::default_instance()
    }
}

impl IMRemoveSessionRsp {
    pub fn new() -> IMRemoveSessionRsp {
        ::std::default::Default::default()
    }

    // required uint32 user_id = 1;


    pub fn get_user_id(&self) -> u32 {
        self.user_id.unwrap_or(0)
    }
    pub fn clear_user_id(&mut self) {
        self.user_id = ::std::option::Option::None;
    }

    pub fn has_user_id(&self) -> bool {
        self.user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: u32) {
        self.user_id = ::std::option::Option::Some(v);
    }

    // required uint32 result_code = 2;


    pub fn get_result_code(&self) -> u32 {
        self.result_code.unwrap_or(0)
    }
    pub fn clear_result_code(&mut self) {
        self.result_code = ::std::option::Option::None;
    }

    pub fn has_result_code(&self) -> bool {
        self.result_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result_code(&mut self, v: u32) {
        self.result_code = ::std::option::Option::Some(v);
    }

    // required .IM.BaseDefine.SessionType session_type = 3;


    pub fn get_session_type(&self) -> super::IM_BaseDefine::SessionType {
        self.session_type.unwrap_or(super::IM_BaseDefine::SessionType::SESSION_TYPE_SINGLE)
    }
    pub fn clear_session_type(&mut self) {
        self.session_type = ::std::option::Option::None;
    }

    pub fn has_session_type(&self) -> bool {
        self.session_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_type(&mut self, v: super::IM_BaseDefine::SessionType) {
        self.session_type = ::std::option::Option::Some(v);
    }

    // required uint32 session_id = 4;


    pub fn get_session_id(&self) -> u32 {
        self.session_id.unwrap_or(0)
    }
    pub fn clear_session_id(&mut self) {
        self.session_id = ::std::option::Option::None;
    }

    pub fn has_session_id(&self) -> bool {
        self.session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_id(&mut self, v: u32) {
        self.session_id = ::std::option::Option::Some(v);
    }

    // optional bytes attach_data = 20;


    pub fn get_attach_data(&self) -> &[u8] {
        match self.attach_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_attach_data(&mut self) {
        self.attach_data.clear();
    }

    pub fn has_attach_data(&self) -> bool {
        self.attach_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attach_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.attach_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attach_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.attach_data.is_none() {
            self.attach_data.set_default();
        }
        self.attach_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_attach_data(&mut self) -> ::std::vec::Vec<u8> {
        self.attach_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for IMRemoveSessionRsp {
    fn is_initialized(&self) -> bool {
        if self.user_id.is_none() {
            return false;
        }
        if self.result_code.is_none() {
            return false;
        }
        if self.session_type.is_none() {
            return false;
        }
        if self.session_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.user_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.result_code = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.session_type, 3, &mut self.unknown_fields)?
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.session_id = ::std::option::Option::Some(tmp);
                },
                20 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.attach_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.user_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.result_code {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.session_type {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(v) = self.session_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.attach_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(20, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.user_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.result_code {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.session_type {
            os.write_enum(3, v.value())?;
        }
        if let Some(v) = self.session_id {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.attach_data.as_ref() {
            os.write_bytes(20, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IMRemoveSessionRsp {
        IMRemoveSessionRsp::new()
    }

    fn default_instance() -> &'static IMRemoveSessionRsp {
        static mut instance: ::protobuf::lazy::Lazy<IMRemoveSessionRsp> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IMRemoveSessionRsp,
        };
        unsafe {
            instance.get(IMRemoveSessionRsp::new)
        }
    }
}

impl ::protobuf::Clear for IMRemoveSessionRsp {
    fn clear(&mut self) {
        self.user_id = ::std::option::Option::None;
        self.result_code = ::std::option::Option::None;
        self.session_type = ::std::option::Option::None;
        self.session_id = ::std::option::Option::None;
        self.attach_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for IMRemoveSessionRsp {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct IMAllUserReq {
    // message fields
    user_id: ::std::option::Option<u32>,
    latest_update_time: ::std::option::Option<u32>,
    attach_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IMAllUserReq {
    fn default() -> &'a IMAllUserReq {
        <IMAllUserReq as ::protobuf::Message>::default_instance()
    }
}

impl IMAllUserReq {
    pub fn new() -> IMAllUserReq {
        ::std::default::Default::default()
    }

    // required uint32 user_id = 1;


    pub fn get_user_id(&self) -> u32 {
        self.user_id.unwrap_or(0)
    }
    pub fn clear_user_id(&mut self) {
        self.user_id = ::std::option::Option::None;
    }

    pub fn has_user_id(&self) -> bool {
        self.user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: u32) {
        self.user_id = ::std::option::Option::Some(v);
    }

    // required uint32 latest_update_time = 2;


    pub fn get_latest_update_time(&self) -> u32 {
        self.latest_update_time.unwrap_or(0)
    }
    pub fn clear_latest_update_time(&mut self) {
        self.latest_update_time = ::std::option::Option::None;
    }

    pub fn has_latest_update_time(&self) -> bool {
        self.latest_update_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_latest_update_time(&mut self, v: u32) {
        self.latest_update_time = ::std::option::Option::Some(v);
    }

    // optional bytes attach_data = 20;


    pub fn get_attach_data(&self) -> &[u8] {
        match self.attach_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_attach_data(&mut self) {
        self.attach_data.clear();
    }

    pub fn has_attach_data(&self) -> bool {
        self.attach_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attach_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.attach_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attach_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.attach_data.is_none() {
            self.attach_data.set_default();
        }
        self.attach_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_attach_data(&mut self) -> ::std::vec::Vec<u8> {
        self.attach_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for IMAllUserReq {
    fn is_initialized(&self) -> bool {
        if self.user_id.is_none() {
            return false;
        }
        if self.latest_update_time.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.user_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.latest_update_time = ::std::option::Option::Some(tmp);
                },
                20 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.attach_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.user_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.latest_update_time {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.attach_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(20, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.user_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.latest_update_time {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.attach_data.as_ref() {
            os.write_bytes(20, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IMAllUserReq {
        IMAllUserReq::new()
    }

    fn default_instance() -> &'static IMAllUserReq {
        static mut instance: ::protobuf::lazy::Lazy<IMAllUserReq> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IMAllUserReq,
        };
        unsafe {
            instance.get(IMAllUserReq::new)
        }
    }
}

impl ::protobuf::Clear for IMAllUserReq {
    fn clear(&mut self) {
        self.user_id = ::std::option::Option::None;
        self.latest_update_time = ::std::option::Option::None;
        self.attach_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for IMAllUserReq {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct IMAllUserRsp {
    // message fields
    user_id: ::std::option::Option<u32>,
    latest_update_time: ::std::option::Option<u32>,
    user_list: ::protobuf::RepeatedField<super::IM_BaseDefine::UserInfo>,
    attach_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IMAllUserRsp {
    fn default() -> &'a IMAllUserRsp {
        <IMAllUserRsp as ::protobuf::Message>::default_instance()
    }
}

impl IMAllUserRsp {
    pub fn new() -> IMAllUserRsp {
        ::std::default::Default::default()
    }

    // required uint32 user_id = 1;


    pub fn get_user_id(&self) -> u32 {
        self.user_id.unwrap_or(0)
    }
    pub fn clear_user_id(&mut self) {
        self.user_id = ::std::option::Option::None;
    }

    pub fn has_user_id(&self) -> bool {
        self.user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: u32) {
        self.user_id = ::std::option::Option::Some(v);
    }

    // required uint32 latest_update_time = 2;


    pub fn get_latest_update_time(&self) -> u32 {
        self.latest_update_time.unwrap_or(0)
    }
    pub fn clear_latest_update_time(&mut self) {
        self.latest_update_time = ::std::option::Option::None;
    }

    pub fn has_latest_update_time(&self) -> bool {
        self.latest_update_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_latest_update_time(&mut self, v: u32) {
        self.latest_update_time = ::std::option::Option::Some(v);
    }

    // repeated .IM.BaseDefine.UserInfo user_list = 3;


    pub fn get_user_list(&self) -> &[super::IM_BaseDefine::UserInfo] {
        &self.user_list
    }
    pub fn clear_user_list(&mut self) {
        self.user_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_list(&mut self, v: ::protobuf::RepeatedField<super::IM_BaseDefine::UserInfo>) {
        self.user_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_user_list(&mut self) -> &mut ::protobuf::RepeatedField<super::IM_BaseDefine::UserInfo> {
        &mut self.user_list
    }

    // Take field
    pub fn take_user_list(&mut self) -> ::protobuf::RepeatedField<super::IM_BaseDefine::UserInfo> {
        ::std::mem::replace(&mut self.user_list, ::protobuf::RepeatedField::new())
    }

    // optional bytes attach_data = 20;


    pub fn get_attach_data(&self) -> &[u8] {
        match self.attach_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_attach_data(&mut self) {
        self.attach_data.clear();
    }

    pub fn has_attach_data(&self) -> bool {
        self.attach_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attach_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.attach_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attach_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.attach_data.is_none() {
            self.attach_data.set_default();
        }
        self.attach_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_attach_data(&mut self) -> ::std::vec::Vec<u8> {
        self.attach_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for IMAllUserRsp {
    fn is_initialized(&self) -> bool {
        if self.user_id.is_none() {
            return false;
        }
        if self.latest_update_time.is_none() {
            return false;
        }
        for v in &self.user_list {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.user_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.latest_update_time = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.user_list)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.attach_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.user_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.latest_update_time {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.user_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.attach_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(20, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.user_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.latest_update_time {
            os.write_uint32(2, v)?;
        }
        for v in &self.user_list {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.attach_data.as_ref() {
            os.write_bytes(20, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IMAllUserRsp {
        IMAllUserRsp::new()
    }

    fn default_instance() -> &'static IMAllUserRsp {
        static mut instance: ::protobuf::lazy::Lazy<IMAllUserRsp> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IMAllUserRsp,
        };
        unsafe {
            instance.get(IMAllUserRsp::new)
        }
    }
}

impl ::protobuf::Clear for IMAllUserRsp {
    fn clear(&mut self) {
        self.user_id = ::std::option::Option::None;
        self.latest_update_time = ::std::option::Option::None;
        self.user_list.clear();
        self.attach_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for IMAllUserRsp {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct IMUsersStatReq {
    // message fields
    user_id: ::std::option::Option<u32>,
    user_id_list: ::std::vec::Vec<u32>,
    attach_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IMUsersStatReq {
    fn default() -> &'a IMUsersStatReq {
        <IMUsersStatReq as ::protobuf::Message>::default_instance()
    }
}

impl IMUsersStatReq {
    pub fn new() -> IMUsersStatReq {
        ::std::default::Default::default()
    }

    // required uint32 user_id = 1;


    pub fn get_user_id(&self) -> u32 {
        self.user_id.unwrap_or(0)
    }
    pub fn clear_user_id(&mut self) {
        self.user_id = ::std::option::Option::None;
    }

    pub fn has_user_id(&self) -> bool {
        self.user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: u32) {
        self.user_id = ::std::option::Option::Some(v);
    }

    // repeated uint32 user_id_list = 2;


    pub fn get_user_id_list(&self) -> &[u32] {
        &self.user_id_list
    }
    pub fn clear_user_id_list(&mut self) {
        self.user_id_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_id_list(&mut self, v: ::std::vec::Vec<u32>) {
        self.user_id_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_user_id_list(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.user_id_list
    }

    // Take field
    pub fn take_user_id_list(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.user_id_list, ::std::vec::Vec::new())
    }

    // optional bytes attach_data = 20;


    pub fn get_attach_data(&self) -> &[u8] {
        match self.attach_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_attach_data(&mut self) {
        self.attach_data.clear();
    }

    pub fn has_attach_data(&self) -> bool {
        self.attach_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attach_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.attach_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attach_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.attach_data.is_none() {
            self.attach_data.set_default();
        }
        self.attach_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_attach_data(&mut self) -> ::std::vec::Vec<u8> {
        self.attach_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for IMUsersStatReq {
    fn is_initialized(&self) -> bool {
        if self.user_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.user_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.user_id_list)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.attach_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.user_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.user_id_list {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.attach_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(20, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.user_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.user_id_list {
            os.write_uint32(2, *v)?;
        };
        if let Some(ref v) = self.attach_data.as_ref() {
            os.write_bytes(20, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IMUsersStatReq {
        IMUsersStatReq::new()
    }

    fn default_instance() -> &'static IMUsersStatReq {
        static mut instance: ::protobuf::lazy::Lazy<IMUsersStatReq> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IMUsersStatReq,
        };
        unsafe {
            instance.get(IMUsersStatReq::new)
        }
    }
}

impl ::protobuf::Clear for IMUsersStatReq {
    fn clear(&mut self) {
        self.user_id = ::std::option::Option::None;
        self.user_id_list.clear();
        self.attach_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for IMUsersStatReq {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct IMUsersStatRsp {
    // message fields
    user_id: ::std::option::Option<u32>,
    user_stat_list: ::protobuf::RepeatedField<super::IM_BaseDefine::UserStat>,
    attach_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IMUsersStatRsp {
    fn default() -> &'a IMUsersStatRsp {
        <IMUsersStatRsp as ::protobuf::Message>::default_instance()
    }
}

impl IMUsersStatRsp {
    pub fn new() -> IMUsersStatRsp {
        ::std::default::Default::default()
    }

    // required uint32 user_id = 1;


    pub fn get_user_id(&self) -> u32 {
        self.user_id.unwrap_or(0)
    }
    pub fn clear_user_id(&mut self) {
        self.user_id = ::std::option::Option::None;
    }

    pub fn has_user_id(&self) -> bool {
        self.user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: u32) {
        self.user_id = ::std::option::Option::Some(v);
    }

    // repeated .IM.BaseDefine.UserStat user_stat_list = 2;


    pub fn get_user_stat_list(&self) -> &[super::IM_BaseDefine::UserStat] {
        &self.user_stat_list
    }
    pub fn clear_user_stat_list(&mut self) {
        self.user_stat_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_stat_list(&mut self, v: ::protobuf::RepeatedField<super::IM_BaseDefine::UserStat>) {
        self.user_stat_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_user_stat_list(&mut self) -> &mut ::protobuf::RepeatedField<super::IM_BaseDefine::UserStat> {
        &mut self.user_stat_list
    }

    // Take field
    pub fn take_user_stat_list(&mut self) -> ::protobuf::RepeatedField<super::IM_BaseDefine::UserStat> {
        ::std::mem::replace(&mut self.user_stat_list, ::protobuf::RepeatedField::new())
    }

    // optional bytes attach_data = 20;


    pub fn get_attach_data(&self) -> &[u8] {
        match self.attach_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_attach_data(&mut self) {
        self.attach_data.clear();
    }

    pub fn has_attach_data(&self) -> bool {
        self.attach_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attach_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.attach_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attach_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.attach_data.is_none() {
            self.attach_data.set_default();
        }
        self.attach_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_attach_data(&mut self) -> ::std::vec::Vec<u8> {
        self.attach_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for IMUsersStatRsp {
    fn is_initialized(&self) -> bool {
        if self.user_id.is_none() {
            return false;
        }
        for v in &self.user_stat_list {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.user_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.user_stat_list)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.attach_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.user_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.user_stat_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.attach_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(20, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.user_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.user_stat_list {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.attach_data.as_ref() {
            os.write_bytes(20, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IMUsersStatRsp {
        IMUsersStatRsp::new()
    }

    fn default_instance() -> &'static IMUsersStatRsp {
        static mut instance: ::protobuf::lazy::Lazy<IMUsersStatRsp> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IMUsersStatRsp,
        };
        unsafe {
            instance.get(IMUsersStatRsp::new)
        }
    }
}

impl ::protobuf::Clear for IMUsersStatRsp {
    fn clear(&mut self) {
        self.user_id = ::std::option::Option::None;
        self.user_stat_list.clear();
        self.attach_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for IMUsersStatRsp {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct IMChangeAvatarReq {
    // message fields
    user_id: ::std::option::Option<u32>,
    avatar_url: ::protobuf::SingularField<::std::string::String>,
    attach_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IMChangeAvatarReq {
    fn default() -> &'a IMChangeAvatarReq {
        <IMChangeAvatarReq as ::protobuf::Message>::default_instance()
    }
}

impl IMChangeAvatarReq {
    pub fn new() -> IMChangeAvatarReq {
        ::std::default::Default::default()
    }

    // required uint32 user_id = 1;


    pub fn get_user_id(&self) -> u32 {
        self.user_id.unwrap_or(0)
    }
    pub fn clear_user_id(&mut self) {
        self.user_id = ::std::option::Option::None;
    }

    pub fn has_user_id(&self) -> bool {
        self.user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: u32) {
        self.user_id = ::std::option::Option::Some(v);
    }

    // required string avatar_url = 2;


    pub fn get_avatar_url(&self) -> &str {
        match self.avatar_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_avatar_url(&mut self) {
        self.avatar_url.clear();
    }

    pub fn has_avatar_url(&self) -> bool {
        self.avatar_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avatar_url(&mut self, v: ::std::string::String) {
        self.avatar_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar_url(&mut self) -> &mut ::std::string::String {
        if self.avatar_url.is_none() {
            self.avatar_url.set_default();
        }
        self.avatar_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_avatar_url(&mut self) -> ::std::string::String {
        self.avatar_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes attach_data = 20;


    pub fn get_attach_data(&self) -> &[u8] {
        match self.attach_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_attach_data(&mut self) {
        self.attach_data.clear();
    }

    pub fn has_attach_data(&self) -> bool {
        self.attach_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attach_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.attach_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attach_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.attach_data.is_none() {
            self.attach_data.set_default();
        }
        self.attach_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_attach_data(&mut self) -> ::std::vec::Vec<u8> {
        self.attach_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for IMChangeAvatarReq {
    fn is_initialized(&self) -> bool {
        if self.user_id.is_none() {
            return false;
        }
        if self.avatar_url.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.user_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.avatar_url)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.attach_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.user_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.avatar_url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.attach_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(20, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.user_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.avatar_url.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.attach_data.as_ref() {
            os.write_bytes(20, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IMChangeAvatarReq {
        IMChangeAvatarReq::new()
    }

    fn default_instance() -> &'static IMChangeAvatarReq {
        static mut instance: ::protobuf::lazy::Lazy<IMChangeAvatarReq> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IMChangeAvatarReq,
        };
        unsafe {
            instance.get(IMChangeAvatarReq::new)
        }
    }
}

impl ::protobuf::Clear for IMChangeAvatarReq {
    fn clear(&mut self) {
        self.user_id = ::std::option::Option::None;
        self.avatar_url.clear();
        self.attach_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for IMChangeAvatarReq {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct IMChangeAvatarRsp {
    // message fields
    user_id: ::std::option::Option<u32>,
    result_code: ::std::option::Option<u32>,
    attach_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IMChangeAvatarRsp {
    fn default() -> &'a IMChangeAvatarRsp {
        <IMChangeAvatarRsp as ::protobuf::Message>::default_instance()
    }
}

impl IMChangeAvatarRsp {
    pub fn new() -> IMChangeAvatarRsp {
        ::std::default::Default::default()
    }

    // required uint32 user_id = 1;


    pub fn get_user_id(&self) -> u32 {
        self.user_id.unwrap_or(0)
    }
    pub fn clear_user_id(&mut self) {
        self.user_id = ::std::option::Option::None;
    }

    pub fn has_user_id(&self) -> bool {
        self.user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: u32) {
        self.user_id = ::std::option::Option::Some(v);
    }

    // required uint32 result_code = 2;


    pub fn get_result_code(&self) -> u32 {
        self.result_code.unwrap_or(0)
    }
    pub fn clear_result_code(&mut self) {
        self.result_code = ::std::option::Option::None;
    }

    pub fn has_result_code(&self) -> bool {
        self.result_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result_code(&mut self, v: u32) {
        self.result_code = ::std::option::Option::Some(v);
    }

    // optional bytes attach_data = 20;


    pub fn get_attach_data(&self) -> &[u8] {
        match self.attach_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_attach_data(&mut self) {
        self.attach_data.clear();
    }

    pub fn has_attach_data(&self) -> bool {
        self.attach_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attach_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.attach_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attach_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.attach_data.is_none() {
            self.attach_data.set_default();
        }
        self.attach_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_attach_data(&mut self) -> ::std::vec::Vec<u8> {
        self.attach_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for IMChangeAvatarRsp {
    fn is_initialized(&self) -> bool {
        if self.user_id.is_none() {
            return false;
        }
        if self.result_code.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.user_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.result_code = ::std::option::Option::Some(tmp);
                },
                20 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.attach_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.user_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.result_code {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.attach_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(20, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.user_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.result_code {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.attach_data.as_ref() {
            os.write_bytes(20, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IMChangeAvatarRsp {
        IMChangeAvatarRsp::new()
    }

    fn default_instance() -> &'static IMChangeAvatarRsp {
        static mut instance: ::protobuf::lazy::Lazy<IMChangeAvatarRsp> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IMChangeAvatarRsp,
        };
        unsafe {
            instance.get(IMChangeAvatarRsp::new)
        }
    }
}

impl ::protobuf::Clear for IMChangeAvatarRsp {
    fn clear(&mut self) {
        self.user_id = ::std::option::Option::None;
        self.result_code = ::std::option::Option::None;
        self.attach_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for IMChangeAvatarRsp {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct IMPCLoginStatusNotify {
    // message fields
    user_id: ::std::option::Option<u32>,
    login_stat: ::std::option::Option<super::IM_BaseDefine::UserStatType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IMPCLoginStatusNotify {
    fn default() -> &'a IMPCLoginStatusNotify {
        <IMPCLoginStatusNotify as ::protobuf::Message>::default_instance()
    }
}

impl IMPCLoginStatusNotify {
    pub fn new() -> IMPCLoginStatusNotify {
        ::std::default::Default::default()
    }

    // required uint32 user_id = 1;


    pub fn get_user_id(&self) -> u32 {
        self.user_id.unwrap_or(0)
    }
    pub fn clear_user_id(&mut self) {
        self.user_id = ::std::option::Option::None;
    }

    pub fn has_user_id(&self) -> bool {
        self.user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: u32) {
        self.user_id = ::std::option::Option::Some(v);
    }

    // required .IM.BaseDefine.UserStatType login_stat = 2;


    pub fn get_login_stat(&self) -> super::IM_BaseDefine::UserStatType {
        self.login_stat.unwrap_or(super::IM_BaseDefine::UserStatType::USER_STATUS_ONLINE)
    }
    pub fn clear_login_stat(&mut self) {
        self.login_stat = ::std::option::Option::None;
    }

    pub fn has_login_stat(&self) -> bool {
        self.login_stat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_login_stat(&mut self, v: super::IM_BaseDefine::UserStatType) {
        self.login_stat = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for IMPCLoginStatusNotify {
    fn is_initialized(&self) -> bool {
        if self.user_id.is_none() {
            return false;
        }
        if self.login_stat.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.user_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.login_stat, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.user_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.login_stat {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.user_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.login_stat {
            os.write_enum(2, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IMPCLoginStatusNotify {
        IMPCLoginStatusNotify::new()
    }

    fn default_instance() -> &'static IMPCLoginStatusNotify {
        static mut instance: ::protobuf::lazy::Lazy<IMPCLoginStatusNotify> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IMPCLoginStatusNotify,
        };
        unsafe {
            instance.get(IMPCLoginStatusNotify::new)
        }
    }
}

impl ::protobuf::Clear for IMPCLoginStatusNotify {
    fn clear(&mut self) {
        self.user_id = ::std::option::Option::None;
        self.login_stat = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for IMPCLoginStatusNotify {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct IMRemoveSessionNotify {
    // message fields
    user_id: ::std::option::Option<u32>,
    session_type: ::std::option::Option<super::IM_BaseDefine::SessionType>,
    session_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IMRemoveSessionNotify {
    fn default() -> &'a IMRemoveSessionNotify {
        <IMRemoveSessionNotify as ::protobuf::Message>::default_instance()
    }
}

impl IMRemoveSessionNotify {
    pub fn new() -> IMRemoveSessionNotify {
        ::std::default::Default::default()
    }

    // required uint32 user_id = 1;


    pub fn get_user_id(&self) -> u32 {
        self.user_id.unwrap_or(0)
    }
    pub fn clear_user_id(&mut self) {
        self.user_id = ::std::option::Option::None;
    }

    pub fn has_user_id(&self) -> bool {
        self.user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: u32) {
        self.user_id = ::std::option::Option::Some(v);
    }

    // required .IM.BaseDefine.SessionType session_type = 2;


    pub fn get_session_type(&self) -> super::IM_BaseDefine::SessionType {
        self.session_type.unwrap_or(super::IM_BaseDefine::SessionType::SESSION_TYPE_SINGLE)
    }
    pub fn clear_session_type(&mut self) {
        self.session_type = ::std::option::Option::None;
    }

    pub fn has_session_type(&self) -> bool {
        self.session_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_type(&mut self, v: super::IM_BaseDefine::SessionType) {
        self.session_type = ::std::option::Option::Some(v);
    }

    // required uint32 session_id = 3;


    pub fn get_session_id(&self) -> u32 {
        self.session_id.unwrap_or(0)
    }
    pub fn clear_session_id(&mut self) {
        self.session_id = ::std::option::Option::None;
    }

    pub fn has_session_id(&self) -> bool {
        self.session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_id(&mut self, v: u32) {
        self.session_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for IMRemoveSessionNotify {
    fn is_initialized(&self) -> bool {
        if self.user_id.is_none() {
            return false;
        }
        if self.session_type.is_none() {
            return false;
        }
        if self.session_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.user_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.session_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.session_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.user_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.session_type {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.session_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.user_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.session_type {
            os.write_enum(2, v.value())?;
        }
        if let Some(v) = self.session_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IMRemoveSessionNotify {
        IMRemoveSessionNotify::new()
    }

    fn default_instance() -> &'static IMRemoveSessionNotify {
        static mut instance: ::protobuf::lazy::Lazy<IMRemoveSessionNotify> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IMRemoveSessionNotify,
        };
        unsafe {
            instance.get(IMRemoveSessionNotify::new)
        }
    }
}

impl ::protobuf::Clear for IMRemoveSessionNotify {
    fn clear(&mut self) {
        self.user_id = ::std::option::Option::None;
        self.session_type = ::std::option::Option::None;
        self.session_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for IMRemoveSessionNotify {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct IMDepartmentReq {
    // message fields
    user_id: ::std::option::Option<u32>,
    latest_update_time: ::std::option::Option<u32>,
    attach_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IMDepartmentReq {
    fn default() -> &'a IMDepartmentReq {
        <IMDepartmentReq as ::protobuf::Message>::default_instance()
    }
}

impl IMDepartmentReq {
    pub fn new() -> IMDepartmentReq {
        ::std::default::Default::default()
    }

    // required uint32 user_id = 1;


    pub fn get_user_id(&self) -> u32 {
        self.user_id.unwrap_or(0)
    }
    pub fn clear_user_id(&mut self) {
        self.user_id = ::std::option::Option::None;
    }

    pub fn has_user_id(&self) -> bool {
        self.user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: u32) {
        self.user_id = ::std::option::Option::Some(v);
    }

    // required uint32 latest_update_time = 2;


    pub fn get_latest_update_time(&self) -> u32 {
        self.latest_update_time.unwrap_or(0)
    }
    pub fn clear_latest_update_time(&mut self) {
        self.latest_update_time = ::std::option::Option::None;
    }

    pub fn has_latest_update_time(&self) -> bool {
        self.latest_update_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_latest_update_time(&mut self, v: u32) {
        self.latest_update_time = ::std::option::Option::Some(v);
    }

    // optional bytes attach_data = 20;


    pub fn get_attach_data(&self) -> &[u8] {
        match self.attach_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_attach_data(&mut self) {
        self.attach_data.clear();
    }

    pub fn has_attach_data(&self) -> bool {
        self.attach_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attach_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.attach_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attach_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.attach_data.is_none() {
            self.attach_data.set_default();
        }
        self.attach_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_attach_data(&mut self) -> ::std::vec::Vec<u8> {
        self.attach_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for IMDepartmentReq {
    fn is_initialized(&self) -> bool {
        if self.user_id.is_none() {
            return false;
        }
        if self.latest_update_time.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.user_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.latest_update_time = ::std::option::Option::Some(tmp);
                },
                20 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.attach_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.user_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.latest_update_time {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.attach_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(20, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.user_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.latest_update_time {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.attach_data.as_ref() {
            os.write_bytes(20, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IMDepartmentReq {
        IMDepartmentReq::new()
    }

    fn default_instance() -> &'static IMDepartmentReq {
        static mut instance: ::protobuf::lazy::Lazy<IMDepartmentReq> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IMDepartmentReq,
        };
        unsafe {
            instance.get(IMDepartmentReq::new)
        }
    }
}

impl ::protobuf::Clear for IMDepartmentReq {
    fn clear(&mut self) {
        self.user_id = ::std::option::Option::None;
        self.latest_update_time = ::std::option::Option::None;
        self.attach_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for IMDepartmentReq {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct IMDepartmentRsp {
    // message fields
    user_id: ::std::option::Option<u32>,
    latest_update_time: ::std::option::Option<u32>,
    dept_list: ::protobuf::RepeatedField<super::IM_BaseDefine::DepartInfo>,
    attach_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IMDepartmentRsp {
    fn default() -> &'a IMDepartmentRsp {
        <IMDepartmentRsp as ::protobuf::Message>::default_instance()
    }
}

impl IMDepartmentRsp {
    pub fn new() -> IMDepartmentRsp {
        ::std::default::Default::default()
    }

    // required uint32 user_id = 1;


    pub fn get_user_id(&self) -> u32 {
        self.user_id.unwrap_or(0)
    }
    pub fn clear_user_id(&mut self) {
        self.user_id = ::std::option::Option::None;
    }

    pub fn has_user_id(&self) -> bool {
        self.user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: u32) {
        self.user_id = ::std::option::Option::Some(v);
    }

    // required uint32 latest_update_time = 2;


    pub fn get_latest_update_time(&self) -> u32 {
        self.latest_update_time.unwrap_or(0)
    }
    pub fn clear_latest_update_time(&mut self) {
        self.latest_update_time = ::std::option::Option::None;
    }

    pub fn has_latest_update_time(&self) -> bool {
        self.latest_update_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_latest_update_time(&mut self, v: u32) {
        self.latest_update_time = ::std::option::Option::Some(v);
    }

    // repeated .IM.BaseDefine.DepartInfo dept_list = 3;


    pub fn get_dept_list(&self) -> &[super::IM_BaseDefine::DepartInfo] {
        &self.dept_list
    }
    pub fn clear_dept_list(&mut self) {
        self.dept_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_dept_list(&mut self, v: ::protobuf::RepeatedField<super::IM_BaseDefine::DepartInfo>) {
        self.dept_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dept_list(&mut self) -> &mut ::protobuf::RepeatedField<super::IM_BaseDefine::DepartInfo> {
        &mut self.dept_list
    }

    // Take field
    pub fn take_dept_list(&mut self) -> ::protobuf::RepeatedField<super::IM_BaseDefine::DepartInfo> {
        ::std::mem::replace(&mut self.dept_list, ::protobuf::RepeatedField::new())
    }

    // optional bytes attach_data = 20;


    pub fn get_attach_data(&self) -> &[u8] {
        match self.attach_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_attach_data(&mut self) {
        self.attach_data.clear();
    }

    pub fn has_attach_data(&self) -> bool {
        self.attach_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attach_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.attach_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attach_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.attach_data.is_none() {
            self.attach_data.set_default();
        }
        self.attach_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_attach_data(&mut self) -> ::std::vec::Vec<u8> {
        self.attach_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for IMDepartmentRsp {
    fn is_initialized(&self) -> bool {
        if self.user_id.is_none() {
            return false;
        }
        if self.latest_update_time.is_none() {
            return false;
        }
        for v in &self.dept_list {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.user_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.latest_update_time = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.dept_list)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.attach_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.user_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.latest_update_time {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.dept_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.attach_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(20, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.user_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.latest_update_time {
            os.write_uint32(2, v)?;
        }
        for v in &self.dept_list {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.attach_data.as_ref() {
            os.write_bytes(20, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IMDepartmentRsp {
        IMDepartmentRsp::new()
    }

    fn default_instance() -> &'static IMDepartmentRsp {
        static mut instance: ::protobuf::lazy::Lazy<IMDepartmentRsp> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IMDepartmentRsp,
        };
        unsafe {
            instance.get(IMDepartmentRsp::new)
        }
    }
}

impl ::protobuf::Clear for IMDepartmentRsp {
    fn clear(&mut self) {
        self.user_id = ::std::option::Option::None;
        self.latest_update_time = ::std::option::Option::None;
        self.dept_list.clear();
        self.attach_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for IMDepartmentRsp {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct IMAvatarChangedNotify {
    // message fields
    changed_user_id: ::std::option::Option<u32>,
    avatar_url: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IMAvatarChangedNotify {
    fn default() -> &'a IMAvatarChangedNotify {
        <IMAvatarChangedNotify as ::protobuf::Message>::default_instance()
    }
}

impl IMAvatarChangedNotify {
    pub fn new() -> IMAvatarChangedNotify {
        ::std::default::Default::default()
    }

    // required uint32 changed_user_id = 1;


    pub fn get_changed_user_id(&self) -> u32 {
        self.changed_user_id.unwrap_or(0)
    }
    pub fn clear_changed_user_id(&mut self) {
        self.changed_user_id = ::std::option::Option::None;
    }

    pub fn has_changed_user_id(&self) -> bool {
        self.changed_user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_changed_user_id(&mut self, v: u32) {
        self.changed_user_id = ::std::option::Option::Some(v);
    }

    // required string avatar_url = 2;


    pub fn get_avatar_url(&self) -> &str {
        match self.avatar_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_avatar_url(&mut self) {
        self.avatar_url.clear();
    }

    pub fn has_avatar_url(&self) -> bool {
        self.avatar_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avatar_url(&mut self, v: ::std::string::String) {
        self.avatar_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar_url(&mut self) -> &mut ::std::string::String {
        if self.avatar_url.is_none() {
            self.avatar_url.set_default();
        }
        self.avatar_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_avatar_url(&mut self) -> ::std::string::String {
        self.avatar_url.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for IMAvatarChangedNotify {
    fn is_initialized(&self) -> bool {
        if self.changed_user_id.is_none() {
            return false;
        }
        if self.avatar_url.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.changed_user_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.avatar_url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.changed_user_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.avatar_url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.changed_user_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.avatar_url.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IMAvatarChangedNotify {
        IMAvatarChangedNotify::new()
    }

    fn default_instance() -> &'static IMAvatarChangedNotify {
        static mut instance: ::protobuf::lazy::Lazy<IMAvatarChangedNotify> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IMAvatarChangedNotify,
        };
        unsafe {
            instance.get(IMAvatarChangedNotify::new)
        }
    }
}

impl ::protobuf::Clear for IMAvatarChangedNotify {
    fn clear(&mut self) {
        self.changed_user_id = ::std::option::Option::None;
        self.avatar_url.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for IMAvatarChangedNotify {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct IMChangeSignInfoReq {
    // message fields
    user_id: ::std::option::Option<u32>,
    sign_info: ::protobuf::SingularField<::std::string::String>,
    attach_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IMChangeSignInfoReq {
    fn default() -> &'a IMChangeSignInfoReq {
        <IMChangeSignInfoReq as ::protobuf::Message>::default_instance()
    }
}

impl IMChangeSignInfoReq {
    pub fn new() -> IMChangeSignInfoReq {
        ::std::default::Default::default()
    }

    // required uint32 user_id = 1;


    pub fn get_user_id(&self) -> u32 {
        self.user_id.unwrap_or(0)
    }
    pub fn clear_user_id(&mut self) {
        self.user_id = ::std::option::Option::None;
    }

    pub fn has_user_id(&self) -> bool {
        self.user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: u32) {
        self.user_id = ::std::option::Option::Some(v);
    }

    // required string sign_info = 2;


    pub fn get_sign_info(&self) -> &str {
        match self.sign_info.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_sign_info(&mut self) {
        self.sign_info.clear();
    }

    pub fn has_sign_info(&self) -> bool {
        self.sign_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sign_info(&mut self, v: ::std::string::String) {
        self.sign_info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sign_info(&mut self) -> &mut ::std::string::String {
        if self.sign_info.is_none() {
            self.sign_info.set_default();
        }
        self.sign_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_sign_info(&mut self) -> ::std::string::String {
        self.sign_info.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes attach_data = 20;


    pub fn get_attach_data(&self) -> &[u8] {
        match self.attach_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_attach_data(&mut self) {
        self.attach_data.clear();
    }

    pub fn has_attach_data(&self) -> bool {
        self.attach_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attach_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.attach_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attach_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.attach_data.is_none() {
            self.attach_data.set_default();
        }
        self.attach_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_attach_data(&mut self) -> ::std::vec::Vec<u8> {
        self.attach_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for IMChangeSignInfoReq {
    fn is_initialized(&self) -> bool {
        if self.user_id.is_none() {
            return false;
        }
        if self.sign_info.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.user_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sign_info)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.attach_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.user_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.sign_info.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.attach_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(20, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.user_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.sign_info.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.attach_data.as_ref() {
            os.write_bytes(20, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IMChangeSignInfoReq {
        IMChangeSignInfoReq::new()
    }

    fn default_instance() -> &'static IMChangeSignInfoReq {
        static mut instance: ::protobuf::lazy::Lazy<IMChangeSignInfoReq> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IMChangeSignInfoReq,
        };
        unsafe {
            instance.get(IMChangeSignInfoReq::new)
        }
    }
}

impl ::protobuf::Clear for IMChangeSignInfoReq {
    fn clear(&mut self) {
        self.user_id = ::std::option::Option::None;
        self.sign_info.clear();
        self.attach_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for IMChangeSignInfoReq {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct IMChangeSignInfoRsp {
    // message fields
    user_id: ::std::option::Option<u32>,
    result_code: ::std::option::Option<u32>,
    sign_info: ::protobuf::SingularField<::std::string::String>,
    attach_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IMChangeSignInfoRsp {
    fn default() -> &'a IMChangeSignInfoRsp {
        <IMChangeSignInfoRsp as ::protobuf::Message>::default_instance()
    }
}

impl IMChangeSignInfoRsp {
    pub fn new() -> IMChangeSignInfoRsp {
        ::std::default::Default::default()
    }

    // required uint32 user_id = 1;


    pub fn get_user_id(&self) -> u32 {
        self.user_id.unwrap_or(0)
    }
    pub fn clear_user_id(&mut self) {
        self.user_id = ::std::option::Option::None;
    }

    pub fn has_user_id(&self) -> bool {
        self.user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: u32) {
        self.user_id = ::std::option::Option::Some(v);
    }

    // required uint32 result_code = 2;


    pub fn get_result_code(&self) -> u32 {
        self.result_code.unwrap_or(0)
    }
    pub fn clear_result_code(&mut self) {
        self.result_code = ::std::option::Option::None;
    }

    pub fn has_result_code(&self) -> bool {
        self.result_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result_code(&mut self, v: u32) {
        self.result_code = ::std::option::Option::Some(v);
    }

    // optional string sign_info = 3;


    pub fn get_sign_info(&self) -> &str {
        match self.sign_info.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_sign_info(&mut self) {
        self.sign_info.clear();
    }

    pub fn has_sign_info(&self) -> bool {
        self.sign_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sign_info(&mut self, v: ::std::string::String) {
        self.sign_info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sign_info(&mut self) -> &mut ::std::string::String {
        if self.sign_info.is_none() {
            self.sign_info.set_default();
        }
        self.sign_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_sign_info(&mut self) -> ::std::string::String {
        self.sign_info.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes attach_data = 20;


    pub fn get_attach_data(&self) -> &[u8] {
        match self.attach_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_attach_data(&mut self) {
        self.attach_data.clear();
    }

    pub fn has_attach_data(&self) -> bool {
        self.attach_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attach_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.attach_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attach_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.attach_data.is_none() {
            self.attach_data.set_default();
        }
        self.attach_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_attach_data(&mut self) -> ::std::vec::Vec<u8> {
        self.attach_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for IMChangeSignInfoRsp {
    fn is_initialized(&self) -> bool {
        if self.user_id.is_none() {
            return false;
        }
        if self.result_code.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.user_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.result_code = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sign_info)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.attach_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.user_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.result_code {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.sign_info.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.attach_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(20, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.user_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.result_code {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.sign_info.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.attach_data.as_ref() {
            os.write_bytes(20, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IMChangeSignInfoRsp {
        IMChangeSignInfoRsp::new()
    }

    fn default_instance() -> &'static IMChangeSignInfoRsp {
        static mut instance: ::protobuf::lazy::Lazy<IMChangeSignInfoRsp> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IMChangeSignInfoRsp,
        };
        unsafe {
            instance.get(IMChangeSignInfoRsp::new)
        }
    }
}

impl ::protobuf::Clear for IMChangeSignInfoRsp {
    fn clear(&mut self) {
        self.user_id = ::std::option::Option::None;
        self.result_code = ::std::option::Option::None;
        self.sign_info.clear();
        self.attach_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for IMChangeSignInfoRsp {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct IMSignInfoChangedNotify {
    // message fields
    changed_user_id: ::std::option::Option<u32>,
    sign_info: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IMSignInfoChangedNotify {
    fn default() -> &'a IMSignInfoChangedNotify {
        <IMSignInfoChangedNotify as ::protobuf::Message>::default_instance()
    }
}

impl IMSignInfoChangedNotify {
    pub fn new() -> IMSignInfoChangedNotify {
        ::std::default::Default::default()
    }

    // required uint32 changed_user_id = 1;


    pub fn get_changed_user_id(&self) -> u32 {
        self.changed_user_id.unwrap_or(0)
    }
    pub fn clear_changed_user_id(&mut self) {
        self.changed_user_id = ::std::option::Option::None;
    }

    pub fn has_changed_user_id(&self) -> bool {
        self.changed_user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_changed_user_id(&mut self, v: u32) {
        self.changed_user_id = ::std::option::Option::Some(v);
    }

    // required string sign_info = 2;


    pub fn get_sign_info(&self) -> &str {
        match self.sign_info.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_sign_info(&mut self) {
        self.sign_info.clear();
    }

    pub fn has_sign_info(&self) -> bool {
        self.sign_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sign_info(&mut self, v: ::std::string::String) {
        self.sign_info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sign_info(&mut self) -> &mut ::std::string::String {
        if self.sign_info.is_none() {
            self.sign_info.set_default();
        }
        self.sign_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_sign_info(&mut self) -> ::std::string::String {
        self.sign_info.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for IMSignInfoChangedNotify {
    fn is_initialized(&self) -> bool {
        if self.changed_user_id.is_none() {
            return false;
        }
        if self.sign_info.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.changed_user_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sign_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.changed_user_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.sign_info.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.changed_user_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.sign_info.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IMSignInfoChangedNotify {
        IMSignInfoChangedNotify::new()
    }

    fn default_instance() -> &'static IMSignInfoChangedNotify {
        static mut instance: ::protobuf::lazy::Lazy<IMSignInfoChangedNotify> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IMSignInfoChangedNotify,
        };
        unsafe {
            instance.get(IMSignInfoChangedNotify::new)
        }
    }
}

impl ::protobuf::Clear for IMSignInfoChangedNotify {
    fn clear(&mut self) {
        self.changed_user_id = ::std::option::Option::None;
        self.sign_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for IMSignInfoChangedNotify {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}
